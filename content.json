{"meta":{"title":"Answer","subtitle":"认真且怂，从始而终","description":"愿你的未来永远热泪盈眶.","author":"扶摇就业","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"扶摇就业留言板","date":"2020-10-11T06:13:30.804Z","updated":"2020-10-11T06:15:20.999Z","comments":true,"path":"2020/10/11/扶摇就业留言板/","link":"","permalink":"http://yoursite.com/2020/10/11/扶摇就业留言板/","excerpt":"扶摇就业留言板.","text":"扶摇就业留言板. 希望大家可以把自己投递岗位的面试时间，面试问题分享出来。然后你希望得到哪些单位的内推，也在下面留言。还有你希望我们公众号出一些哪些方面的面经，也在下方留言。","categories":[],"tags":[]},{"title":"","slug":"百度 Android 面经总结第一期","date":"2020-10-10T17:59:08.267Z","updated":"2020-10-10T18:01:15.421Z","comments":true,"path":"2020/10/11/百度 Android 面经总结第一期/","link":"","permalink":"http://yoursite.com/2020/10/11/百度 Android 面经总结第一期/","excerpt":"0.我们的公众号：扶摇就业，欢迎前往，更多面经内推，祝您早日拿到offer奥～ 1.arrayList与LinkedList ArrayList和LinkedList都实现了List接口，他们有以下的不同点：","text":"0.我们的公众号：扶摇就业，欢迎前往，更多面经内推，祝您早日拿到offer奥～ 1.arrayList与LinkedList ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。1) 因为 Array 是基于索引 (index) 的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array获取数据的时间复杂度是 O(1), 但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。 2) 相对于 ArrayList，LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList最坏的一种情况，时间复杂度是 O(n) ，而 LinkedList 中插入或删除的时间复杂度仅为 O(1) 。 ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 3) 类似于插入数据，删除数据时， LinkedList 也优于 ArrayList 。4) LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 2.抽象类和接口 抽象类：1、抽象类使用abstract修饰；2、抽象类不能实例化，即不能使用new关键字来实例化对象；3、含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；4、抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；5、如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；6、抽象类中的抽象方法只有方法体，没有具体实现；接口：1、接口使用interface修饰；2、接口不能被实例化；3、一个类只能继承一个类，但是可以实现多个接口；4、接口中方法均为抽象方法；5、接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现） 3.GC算法 GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（TenuredGeneration）和新生代（Young Generation）,在堆区之外还有一个代就是永久代（PermanetGeneration）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。新生代的回收算法 包含有Enden、form survicor space、to survivorspace三个区，绝大多数最新被创建的对象会被分配到这里，大部分对象在创建之后会变得很快不可达。 ①所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 ②新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 ③当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 ④ 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 老年代的回收算法 ①在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 ②内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，FullGC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 永久代的回收算法用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区。 4.匿名内部类 匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类定义匿名内部类的语法格式如下： new 父类构造器（实参列表) | 实现接口() { //匿名内部类的类体部分 }匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口 匿名内部类不能是抽象类。匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以初始化块，可以通过初始化块来完成构造器需要完成的工作。 5.wait和sleep的区别 sleep 让当前线程休眠指定时间。 休眠时间的准确性依赖于系统时钟和CPU调度机制。不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进入到当前同步块或者同步方法中的。可通过调用interrupt()方法来唤醒休眠线程。 wait让当前线程进入等待状态，当别的其他线程调用notify()或者notifyAll()方法时，当前线程进入就绪状态wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，前提是必须获取对象上的锁资源当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。 6.android相关的handler机制 当我们创建一个handler时，会调用looper的mylooper方法来获得当前线程的looper。如果没有，就会新建一个looper并存放在looper线程池里，保证每个线程都有自己唯一的looper。而looper中持有MessageQueue，当新建一个Message时，通过handler发送时，会将这个Message存放到MessageQueue中，而loop方法一直在循环从messageQueue中取消息，发送的message会被取到，并处理。当发送了多个message时，会遵循先进先出原则维持在messageQueue中。那么，不同线程中发送的message，最终是怎么在主线程中完成处理的呢。要从target的dispatchMessage方法中找答案。 7.service和intentService Service 是长期运行在后台的应用程序组件。 Service 不是一个单独的进程，它和应用程序在同一个进程中，Service也不是一个线程,它和线程没有任何关系，所以它不能直接处理耗时操作。如果直接把耗时操作放在 Service 的onStartCommand() 中，很容易引起 ANR .如果有耗时操作就必须开启一个单独的线程来处理。 IntentService 是继承于 Service 并处理异步请求的一个类，在 IntentService内有一个工作线程来处理耗时操作，启动 IntentService 的方式和启动传统 Service一样，同时，当任务执行完后，IntentService 会自动停止，而不需要我们去手动控制。另外，可以启动 IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService 的 onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。而且，所有请求都在一个单线程中，不会阻塞应用程序的主线程（UI Thread），同一时间只处理一个请求。IntentService 省去了在Service 中手动开线程的麻烦，当操作完成时，不用手动停止 Service。 8.内存泄漏的情况 内存泄漏（MemoryLeak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃(OOM)等严重后果静态变量的生命周期和应用的生命周期一样长。如果静态变量持有某个Activity的context，则会引发对应Activity无法释放，导致内存泄漏。如果持有application的context，就没有问题（以下例子是指Activity销毁时没有释放的情况）常见的有： 单例模式：内部实现是静态变量和方法 静态的View：view默认持有Activity的context 静态Activity匿名内部类或者非静态内部类 常见的包括Handler，AsyncTask，TimerTask等，一般在处理多线程任务的时候非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用 9.自定义view View主要分为两类： a. 单一视图（View）：即一个View，如TextView，不包含子View。 b.视图组（ViewGroup）：即多个View组成的ViewGroup，如LinearLayout，包含子View。Android中的UI组件都由View、ViewGroup组成。View类是Android中各种组件的基类，如View是ViewGroup基类 步骤： 自定义View属性在View的构造方法中获得自定义的属性 重写onMesure 重写onDraw整个View树的绘图流程是在ViewRoot.java类的performTraversals()函数展开的，该函数做的执行过程可简单概况为根据之前设置的状态，判断是否需要重新计算视图大小(measure)、是否重新需要安置视图的位置(layout)、以及是否需要重绘(draw) 10.事件分发机制 当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件）Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象将点击事件（MotionEvent）传递到某个具体的View &amp; 处理的整个过程 即 事件传递的过程 = 分发过程 基本会遵从 Activity =&gt; ViewGroup =&gt; View 的顺序进行事件分发，然后通过调用 onTouchEvent()方法进行事件的处理。我们在项目中一般会对MotionEvent.ACTION_DOWN，MotionEvent.ACTION_UP，MotionEvent.ACTION_MOVE，MotionEvent.ACTION_CANCEL分情况进行操作。 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()协作完成 11.requestLayout和invalidate方法调用后，onlayout，onmeasure，onDraw的执行情况 invalidate()方法 ：说明：请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些“需要重绘的”视图，即谁(View的话，只绘制该View；ViewGroup，则绘制整个ViewGroup)请求invalidate()方法，就绘制该视图。 requestLayout()方法 ：会导致调用measure()过程 和 layout()过程。说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制 12.activity的启动模式 Activity的启动分为两种方式，显示方式和隐式方式，显示方式就是在通过intent启动Activity时指定了Activity的包名和类名，而隐式方式则在初始化Intent时只指定action或action和data属性。","categories":[],"tags":[]},{"title":"","slug":"字节跳动 C++面经总结第四期","date":"2020-10-10T17:55:47.503Z","updated":"2020-10-10T18:00:56.285Z","comments":true,"path":"2020/10/11/字节跳动 C++面经总结第四期/","link":"","permalink":"http://yoursite.com/2020/10/11/字节跳动 C++面经总结第四期/","excerpt":"0.我们的公众号：扶摇就业，欢迎前往，更多面经内推，祝您早日拿到offer奥～ 1.​数组指针和指针数组区别 数组指针只是一个指针变量,是C语言里专门用来指向二维数组的,它占有内存中一个指针的存储空间。指针数组是多个指针变量,以数组形式存在内存当中,占有多个指针的存储空间。","text":"0.我们的公众号：扶摇就业，欢迎前往，更多面经内推，祝您早日拿到offer奥～ 1.​数组指针和指针数组区别 数组指针只是一个指针变量,是C语言里专门用来指向二维数组的,它占有内存中一个指针的存储空间。指针数组是多个指针变量,以数组形式存在内存当中,占有多个指针的存储空间。2.C++多态有哪几种？ 多态：父类型的引用指向子类型的对象 静态多态（函数重载和运算符重载），是在编译的时候，就确定调用函数的类型；动态多态（虚函数实现），在运行的时候，才能确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。 3.C++析构和构造的顺序，为什么析构函数最好是虚函数 1）构造函数顺序：先基类、再数据成员中是类对象的构造函数、最后派生类构造函数的函数体 2）析构函数顺序：与构造函数相反​3）析构函数最好是虚函数：若派生类有一个指向动态内存分配的数据成员，而又将基类的指针指向派生类对象，同时基类的析构函数又不是虚函数的话，编译器就实施静态绑定，释放基类指针所指对象的空间时候只执行基类的析构函数，不执行派生类的析构函数，那派生类动态分配的数据成员所申请的空间就不能被释放，这就造成了内存泄漏。 4.进程间的通信方式 1）管道：半双工通信方式、数据单向流动、只能在父子进程间使用 2）命名管道：半双工，允许无亲缘关系进程间的通信3）信号量：计数器，控制多个进程对共享资源的访问4）共享内存：映射一段能被其他进程所访问的内存5）消息队列：消息的链表，存放在内核中并由消息队列标识符标识6）套接字：不同设备间的进程通信7）全双工管道 5.同步和异步的概念 所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回，不继续执行后续操作所谓异步，就是发出一个功能调用时，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回非阻塞调用指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回同步是个过程，阻塞是线程的一种状态。多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区，在这个过程中，后进入临界区的线程将阻塞，等待先进入的线程走出临界区。 6.OSI、TCP/IP、五层协议的体系结构、以及各层协议作用 OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP分层（4层）：网络接口层、 网际层、运输层、应用层。 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX会话层：NFS、sql、NETBiOS、RPC 表示层：JPEG、MPEG、ASII应用层：FTP、DNS、HTTP、SMTP、WWW、NFS、Telent 每一层的作用如下：物理层：通过媒介传输比特，确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 7.简述快速排序过程 1）选择一个基准元素,通常选择第一个元素或者最后一个元素,2）通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。3）此时基准元素在其排好序后的正确位置 4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。 8.快速排序的改进 只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为8 左右时,改进算法的性能最佳。 选择基准元的方式对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。方法1 固定基准元如果输入序列是随机的，处理时间是可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。 方法2随机基准元这是一种相对安全的策略。由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。方法3三数取中引入的原因：虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取基准。分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准元。 9.TCP和UDP的区别？ 1. TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。2. TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。3. TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。附：TCP对应的协议和UDP对应的协议 TCP对应的协议： （1） FTP：定义了文件传输协议，使用21端口。 （2）Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 （3）SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 （4）POP3：它是和SMTP对应，POP3用于接收邮件。pop3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。默认端口：80 UDP对应的协议： （1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 （2）SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 （3）TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 10.代码题：一个数组里面多个元素和等于target的答案数（多个元素可以不连续） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead)&#123; if( pHead == NULL ) return pHead;ListNode *pre = NULL; //指向前面最晚访问过的不重复结点 ListNode *p = pHead; //指向当前处理的结点 ListNode *q = NULL; //指向当前处理结点后面结点while( p != NULL ) &#123; //当前结点p，（其实是p指向当前结点），与它下一个结点p-&gt;next的val相同，说明要删掉有这个val的所有结点 if( p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;val == p-&gt;val ) &#123; q = p-&gt;next;//找到q，它指向最后一个与p val相同的结点，那p 到 q （包含） 都是要删除的 while( q != NULL &amp;&amp; q-&gt;next != NULL &amp;&amp; q-&gt;next-&gt;val == p-&gt;val ) &#123; q = q-&gt;next; &#125;//如果p指向链表中第一个元素，p -&gt; ... -&gt; q -&gt;... , 要删除p到q, 将指向链表第一个元素的指针pHead指向q-&gt;next。 if( p == pHead ) &#123; pHead = q-&gt;next; &#125; else//如果p不指向链表中第一个元素，pre -&gt; p -&gt;...-&gt;q -&gt;... ，要删除p到q，即pre-&gt;next = q-&gt;next &#123; pre-&gt;next = q-&gt;next; &#125; //当前处理的p要向链表尾部移动 p = q-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; return pHead;&#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"字节跳动 C++面经总结第三期","date":"2020-10-10T17:53:23.155Z","updated":"2020-10-10T18:00:44.180Z","comments":true,"path":"2020/10/11/字节跳动 C++面经总结第三期/","link":"","permalink":"http://yoursite.com/2020/10/11/字节跳动 C++面经总结第三期/","excerpt":"0.我们的公众号：扶摇就业，欢迎前往，更多面经 1.死锁概念 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。","text":"0.我们的公众号：扶摇就业，欢迎前往，更多面经 1.死锁概念 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。2.死锁产生原因 争夺资源 进程间推进顺序非法 3.死锁产生的必要条件 （1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 4.死锁处理办法 预防破坏”请求与保持”条件：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。 避免 系统处于安全状态（存在能让所有进程执行完的序列），可避免死锁 系统处于不安全状态，可能进入死锁状态（银行家算法） 检测 资源分配图不可完全简化，则是死锁状态 解除 处理抢占资源 / 终止死锁进程 5.堆和栈的区别 先来看一个网上很流行的经典例子：//main.cpp int a = 0; 全局初始化区 char p1; 全局未初始化区 main(){ int b; 栈 char s[] = “abc”; 栈 char p2; 栈 char p3 = “123456”;123456/0在常量区，p3在栈上。 static int c =0；全局（静态）初始化区 p1 = (char )malloc(10); p2 = (char *)malloc(20); 分配得来得10和20字节的区域就在堆区。 strcpy(p1, “123456”); 123456/0放在常量区，编译器可能会将它与p3所指向的”123456” 优化成一个地方。 } 申请方式不同 栈（英文名称是stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。而堆（英文名称是heap）则是程序员根据需要自己申请的空间，例如malloc（10）；开辟十个字节的空间。 申请后系统的响应 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆。结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请效率的比较 栈：由系统自动分配，速度较快。但程序员是无法控制的。 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 申请大小的限制 在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 堆和栈中的存储内容 由于栈的大小有限，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 6.HTTPS加密传输过程 HTTPS全称Hyper Text Transfer Protocol over SecureSocketLayer，是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS在HTTP的基础下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 知识储备技能库 ​ HTTP HTTP是应用层协议，默认运行在80端口，是一种不安全的传输协议，经其传输的数据都是未加密的明文数据。HTTP协议（HyperTextTransferProtocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件, 图片文件, 查询结果等）。 HTTPS HTTPS （全称：Hyper Text Transfer Protocol over SecureSocketLayer），是应用层协议，默认运行在443端口，是以安全为目标的 HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面 。 SSL SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport LayerSecurity，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL RecordProtocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSLHandshakeProtocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 TLS 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议（TLS Record）和TLS 握手协议（TLS Handshake）。 对称加密 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 非对称加密 非对称加密算法是一种密钥的保密方法。非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将公钥公开，需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；甲方再用自己私钥对加密后的信息进行解密。甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密。另一方面，甲方可以使用自己的私钥对机密信息进行签名后再发送给乙方；乙方再用甲方的公钥对甲方发送回来的数据进行验签。甲方只能用其私钥解密由其公钥加密后的任何信息。非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。 传输过程 1、服务器将携带的公钥向数字证书机构申请证书。 2、数字证书机构用自己的私钥对公钥签名颁发证书，并返回给服务器。3、服务器将申请携带公钥的证书分发给客服端。4、客户端验证证书，证书机构通过验证，或者用户接受不受信任的证书(非权威机构颁发的证书)。获取到公钥。到这一步，在证书保证下服务器拥有私钥，客户端拥有公钥，可进行非对称性加密。5、使用公钥加密报文发送给服务器，其中携带随机串。其中的随机串用户传输数据时进行对称加密 6、服务器使用私钥解密。获取报文信息及随机串。7、解密后服务器发送握手消息给客户端。 8、客户端接受握手消息，握手结束，双方确定加密算法(使用随机串确定的对称性加密)，开始传输。 7.算法题：二分查找 算法思想：取中间的数缩小查找范围，对应不同的题目变形，在取到中间数mid确定下一个查找范围时也有不同，左边界有的low=mid+1,也可能low=mid,右边界有的high=mid-1,也有可能high=mid。 对于一个排序数组来说二分查找的时间复杂度是O(logn) 算法实现： 123456789101112#include int binary_search(int key,int a[],int n) //自定义函数binary_search() &#123; int low,high,mid,count=0,count1=0; low=0;&gt; high=n-1; while(low&lt;high) 査找范围不为0时执行循环体语句 &#123; count++; //count记录査找次数&gt; mid=(low+high)/2; //求中间位置 if(key&lt;a[mid]) key小于中间值时 high=mid-1;&gt; //确定左子表范围 else if(key&gt;a[mid]) //key 大于中间值时 low=mid+1; //确定右子表范围 else&gt; if(key==a[mid]) //当key等于中间值时，证明查找成功 &#123; printf(&quot;查找成功!\\n 查找 %d&gt; 次!a[%d]=%d&quot;,count,mid,key); //输出査找次数及所査找元素在数组中的位置 count1++;&gt; //count1记录查找成功次数 break; &#125; &#125; if(count1==0) //判断是否查找失敗 printf(&quot;查找失敗!&quot;);&gt; //査找失敗输出no found return 0; &#125; int main() &#123; int i,key,a[100],n;&gt; printf(&quot;请输入数组的长度：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); //输入数组元素个数&gt; printf(&quot;请输入数组元素：\\n&quot;); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);&gt; //输入有序数列到数组a中 printf(&quot;请输入你想查找的元素：\\n&quot;); scanf(&quot;%d&quot;,&amp;key); //输入要^找的关键字&gt; binary_search(key,a,n); //调用自定义函数 printf(&quot;\\n&quot;); return 0; &#125;","categories":[],"tags":[]},{"title":"","slug":"字节跳动 C++面经总结第二期","date":"2020-10-10T17:50:00.655Z","updated":"2020-10-10T18:00:26.642Z","comments":true,"path":"2020/10/11/字节跳动 C++面经总结第二期/","link":"","permalink":"http://yoursite.com/2020/10/11/字节跳动 C++面经总结第二期/","excerpt":"我们的公众号：扶摇就业，获取更多面经参考 1.算法：查找二叉树中两个节点的最近公共祖先","text":"我们的公众号：扶摇就业，获取更多面经参考 1.算法：查找二叉树中两个节点的最近公共祖先算法思想：这道题的关键在于每个节点中包含指向父节点的指针，这使得程序可以用一个简单的算法实现。首先给出p的父节点p-&gt;parent，然后将q的所有父节点依次和p-&gt;parent作比较，如果发现两个节点相等，则该节点就是最近公共祖先，直接将其返回。如果没找到相等节点，则将q的所有父节点依次和p-&gt;parent-&gt;parent作比较……直到p-&gt;parent==root，复杂度稍高O(n2) Node NearestCommonAncestor(Node root,Node p,Node q) { Node * temp; while(p!=NULL) { p=p-&gt;parent; temp=q; while(temp!=NULL) { if(p==temp-&gt;parent) return p; temp=temp-&gt;parent; } } } 2.算法：如何判断一颗树是否是完全二叉树 思想：根据完全二叉树的定义，对完全二叉树按照从上到下、从左到右的层次遍历，应该满足一下两条要求： ●某节点没有左孩子，则一定无右孩子 ●若某节点缺左或右孩子，则其所有后继一定无孩子 ​若不满足上述任何一条，均不为完全二叉树。 算法思路：采用层序遍历算法，用cm变量值表示迄今为止二叉树为完全二叉树（其初值为1，一旦发现不满足上述条件之一，则置cm为0），bj变量值表示迄今为止所有节点均有左右孩子（其初值为1），一旦发现一个节点没有左孩子或没有右孩子时置bj为0），在遍历完毕后返回cm的值。 对应的算法如下： int CompBTNode(BTNode * b){ BTNode Qu[MaxSize],p; //定义一个队列，用于层次遍历 int front=0,rear=0; //队头、队尾指针 int cm=1; int bj=1; if(b!=NULL) { rear++; Qu[rear]=b; //进队 while(front!=rear) { front++; p=Qu[front]; if(p-&gt;lchild==NULL) //*p节点没有左孩子 { bj=0; if(p-&gt;rchild!=NULL) //没有左孩子但有右孩子 cm=0; //则不是完全二叉树 } else //*p节点有左子树 { if(bj==1) //迄今为止，所有节点均有左右孩子 { rear++; //左孩子进队 Qu[rear]=b-&gt;lchild; if(p-&gt;rchild==NULL) //*p有左孩子但没有右孩子 bj=0; else { rear++; //右孩子进队 Qu[rear]=p-&gt;rchild; } else //bj=0:迄今为止，已有节点缺孩子 cm=0; //而此时*p节点有左孩子，违反（2） } } return cm; } return 1; //把空树当成特殊的完全二叉树 } 3.算法：字符串反转 算法思想：观察特征，第一个字符和最后一个字符更换，第二个字符和倒数第二个更换…以此类推 class Solution { public: string reverseString(string str) { int length = str.length(); //计算多少对，向下取整 int pair = length / 2; int last; for (int i = 0; i &lt; pair; ++i) { last = length - i - 1; char temp = str.at(i); str.at(i) = str.at(last); str.at(last) = temp; } return str; } }; 4.说一说虚函数和纯虚函数 语法规范： 1.在类成员方法的声明（不是定义）语句前面加个单词：virtual，就成为虚函数； 2.在虚函数的声明语句末尾中加个 =0 ，就成为纯虚函数； 3.子类可以重新定义基类的虚函数，称之为复写（override）； 4.不管是虚函数还是纯虚函数，基类都可以为他们提供实现（implementation），如果有的话子类可以调用基类的这些实现； 5.子类可自主选择是否要提供一份属于自己的个性化虚函数实现； 6.子类必须提供一份属于自己的个性化纯虚函数实现。 总结： 1.当基类的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供一个备选方案的时候，请将其设计为虚函数。例如飞行器的加油动作，每种不同的飞行器原则上都应该有自己的个性化的加充燃油的方式，但也不免可以有一种通用的燃油加充方式； 2.当基类的某个成员方法，必须由子类提供个性化实现的时候，请将其设计为纯虚函数。例如飞行器的飞行动作，逻辑上每种飞行器都必须提供为其特殊设计的个性化飞行行为，而不应该有任何一种”通用的飞行方式”； 3.使用一个基类类型的指针或者引用，来指向子类对象，进而调用经由子类复写了的个性化的虚函数，这是C++实现多态性的一个最经典的场景； 4.基类提供的纯虚函数的实现版本，并非为了多态性考虑，因为指向子类对象的基类指针和引用无法调用该版本。纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路； 5.虚函数和普通的函数实际上是存储在不同的区域的，虚函数所在的区域是可被覆盖（也称复写override）的，每当子类定义相同名称的虚函数时就将原来基类的版本给覆盖了，另一侧面也说明了为什么基类中声明的虚函数在后代类中不需要另加声明一律自动为虚函数，因为它所存储的位置不会发生改变。而普通函数的存储区域不会覆盖，每个类都有自己独立的区域互不相干。 5.析构函数可以是虚函数吗 析构函数常常是虚函数 创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。 6.指针和引用的区别 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如： int a=1;int *p=&a; int a=1;int &amp;b=a; 上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。 而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。 可以有const指针，但是没有const引用； 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的） 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化； 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 ”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小； 指针和引用的自增(++)运算意义不一样； 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏； http://7.int const p 是什么，那const int**p 又是 一个指向指针的常量指针 一个指向常量指针的指针 8.智能指针了解吗 三种智能指针，shared_ptr, unique_ptr, weak_ptr。 9.shared_ptr的原理 shared_ptr维护了一个指向control block的指针对象，来记录引用个数。 10.weak_ptr的原理 weak_ptr用于避免shared_ptr相互指向产生的环形结构，造成的内存泄漏。weak_ptr count是弱引用个数；弱引用个数不影响shared count和对象本身，shared count为0时则直接销毁。 11.如何判断weak_ptr的对象是否失效？ expired()：检查被引用的对象是否已删除。 lock()会返回shared指针，判断该指针是否为空。 use_count()也可以得到shared引用的个数，但速度较慢。 12.shared 和 unique区别 unique具有唯一性，对指向的对象值存在唯一的unique_ptr。unique_ptr不可复制，赋值，但是move()可以转换对象的所有权，局部变量的返回值除外。与shared_ptr相比，若自定义删除器，需要在声明处指定删除器类型，而shared不需要，shared自定义删除器只需要指定删除器对象即可，在赋值时，可以随意赋值，删除器对象也会被赋值给新的对象。 13.怎么保证share_ptr线程安全 它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr 有两个数据成员，读写操作不能原子化。根据文档11，shared_ptr 的线程安全级别和内建类型、标准库容器、std::string 一样，即： 一个shared_ptr 对象实体可被多个线程同时读取； 两个shared_ptr 对象实体可以被两个线程同时写入，“析构”算写操作； 如果要从多个线程读写同一个shared_ptr 对象，那么需要加锁。 请注意，以上是shared_ptr 对象本身的线程安全级别，不是它管理的对象的线程安全级别。 要在多个线程中同时访问同一个shared_ptr，正确的做法是用mutex 保护： MutexLock mutex; // No need for ReaderWriterLock shared_ptr globalPtr; // 我们的任务是把globalPtr 安全地传给doit() void doit(const shared_ptr&amp; pFoo); globalPtr 能被多个线程看到，那么它的读写需要加锁。注意我们不必用读写锁，而只用最简单的互斥锁，这是为了性能考虑。因为临界区非常小，用互斥锁也不会阻塞并发读。 为了拷贝globalPtr，需要在读取它的时候加锁，即： void read() { shared_ptr localPtr; { MutexLockGuard lock(mutex); localPtr = globalPtr; // read globalPtr } // use localPtr since here，读写localPtr 也无须加锁 doit(localPtr); } 写入的时候也要加锁： void write() { shared_ptr newPtr(new Foo); // 注意，对象的创建在临界区之外 { MutexLockGuard lock(mutex); globalPtr = newPtr; // write to globalPtr } // use newPtr since here，读写newPtr 无须加锁 doit(newPtr); } 14.操作符重载 1.操作符函数: 在特定条件下,编译器有能力把一个由操作数和操作符共同组成的表达式,解释为对 一个全局或成员函数的调用,该全局或成员函数被称为操作符函数.该全局或成员函数 被称为操作符函数.通过定义操作符函数,可以实现针对自定义类型的运算法则,并使之 与内置类型一样参与各种表达式运算. 2.首先我们先介绍下左值和右值,因为我们在运用运算符的时候要尽量和内置类型的一致性. 左值:有名的可以直接取地址的我们称之为左值,左值的特性是可以修改的. 右值:右值主要是一些临时变量,匿名变量,字符串字面值常量,字符常量; 表达式有的是左值有的是右值,例如+-*/运算返回的是右值,而赋值运算,复合赋值运算 返回的是左值.前++返回的是左值,后++返回的是右值. 类型转换(无论是显示的还是隐式的)都伴随着临时变量的产生.函数的返回值当返回的 不是引用的时候也是一个右值,但是一个引用的时候返回的是一个左值. 15.强类型语言和弱类型语言 一、强类型语言 强类型语言是一种强制类型定义的语言，一旦某一个变量被定义类型，如果不经过强制转换，则它永远就是该数据类型了，强类型语言包括Java、.net 、Python、C++等语言。举个例子：定义了一个整数，如果不进行强制的类型转换，则不可以将该整数转化为字符串。 二、弱类型语言 弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。弱类型语言包括vb 、PHP、javascript等语言。 三、强类型语言和弱类型语言区别 无论是强类型语言还是弱类型语言，判别的根本是是否会隐性的进行语言类型转变。强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。 16.哈希表怎么解决冲突 一、开放定址法 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。注意：①用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。②空单元的表示与具体的应用相关。 按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等。（1）线性探查法(Linear Probing)该方法的基本思想是：将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：d，d+l，d+2，…，m-1，0，1，…，d-1 即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。探查过程终止于三种情况： (1)若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；(2)若当前探查的单元中含有key，则查找成功，但对于插入意味着失败； (3)若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。利用开放地址法的一般形式，线性探查法的探查序列为：hi=(h(key)+i)％m 0≤i≤m-1 //即di=i用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。② 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。（2）线性补偿探测法线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为：j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。【例】 PDP-11 小型计算机中的汇编程序所用的符合表，就采用此方法来解决冲突，所用表长 m ＝ 1321 ，选用 Q ＝ 25 。（3）随机探测随机探测的基本思想是：将线性探测的步长从常数改为随机数，即令：j ＝ (j ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。 2、拉链法（1）拉链法解决冲突的方法 拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。 （2）拉链法的优点与开放定址法相比，拉链法有如下几个优点：①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 （3）拉链法的缺点 拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 17.哈希表原理 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 记录的存储位置=f(关键字) 这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。 哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。） 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。 18.哪些函数可以用作哈希函数 加法Hash 位运算Hash 乘法Hash 19.mysql查询优化的方法 1.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 2.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及频繁的列上建立索引。 3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.下面的查询也将导致全表扫描：(不能前置百分号) select id from t where name like ‘%abc%’ 若要提高效率，可以考虑全文检索。 http://6.in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 8.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 9.很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 10.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 11.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 12.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 13.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 14.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 15.任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 16.避免频繁创建和删除临时表，以减少系统表资源的消耗。 17.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。 18.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度;如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 19.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 20.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 21.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 22.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 23.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 24.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 25.尽量避免大事务操作，提高系统并发能力。 20.mysql事务的原则 事务具有 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）。","categories":[],"tags":[]},{"title":"","slug":"字节跳动 C++面经总结及解析 第一期","date":"2020-10-10T17:47:25.083Z","updated":"2020-10-10T18:00:10.304Z","comments":true,"path":"2020/10/11/字节跳动 C++面经总结及解析 第一期/","link":"","permalink":"http://yoursite.com/2020/10/11/字节跳动 C++面经总结及解析 第一期/","excerpt":"我们的公众号：扶摇就业，有更多大厂面经 面试题目 1.进程和线程的区别，有了进程为什么还要有线程 2.进程的资源、线程的资源","text":"我们的公众号：扶摇就业，有更多大厂面经 面试题目 1.进程和线程的区别，有了进程为什么还要有线程 2.进程的资源、线程的资源 3.多线程怎么同步，多线程竞争怎么解决 4.进程通信 5.线程之间的通信方式 6.一次完整的http请求过程 7.http和https区别，哪个更快 8.https加密过程 9.HTTP和TCP的区别 10.DNS域名解析过程，用到了什么协议（UDP），最后获得IP地址就能怎样呢（就可以识别在网络中的机器） 11.TCP和UDP区别以及各自使用场景，UDP不可靠的话那为什么咱们现在视频这么流畅，是依靠什么 12.TCP拥塞控制 13.udp可以实现的功能 14.如何使UDP达到和TCP相同的效果 15.new malloc区别 16.new/delete，malloc/free，delete/delete[] 17.static关键字 18.static应用场景 19.虚函数的作用和底层实现（实现多态，虚表 虚表指针） 20.哪些函数不能是虚函数，构造函数为什么不行 题目解析 1. 区别： 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位） 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 为什么： 进程属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。 线程是在进程这个层次上提供的一层并发的抽象： （1）能够使系统在同一时间能够做多件事情； （2）当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行 （3）可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高 2. 一、堆与栈 堆： 是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是 thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换 ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。 二、其他 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：1.线程ID每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。2.寄存器组的值由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。3.线程的堆栈堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。4.错误返回码由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。5.线程的信号屏蔽码由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。6.线程的优先级由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。 3. C++线程同步的四种方式：互斥锁，条件变量，读写锁，信号量 4. 5. 使用全局变量主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile 使用消息实现通信在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;2)添加消息函数声明afx_msg int OnTSendmsg();3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)4)添加OnTSM()的实现函数；5)在线程函数中添加PostMessage消息Post函数 使用事件CEvent类实现线程间通信Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；2)threadStart.SetEvent();使其处于通信状态；3)调用WaitForSingleObject()来监视CEvent对象 6. 一个完整的HTTP过程包括建立连接、数据传输、断开连接等七个步骤。 TCP建立连接 HTTP协议是基于TCP协议来实现的，因此首先就是要通过TCP三次握手与服务器端建立连接，一般HTTP默认的端口号为80； 浏览器发送请求命令 在与服务器建立连接后，Web浏览器会想服务器发送请求命令 浏览器发送请求头消息 在浏览器发送请求命令后，还会发送一些其它信息，最后以一行空白内容告知服务器已经完成头信息的发送； 服务器应答 在收到浏览器发送的请求后，服务器会对其进行回应，应答的第一部分是协议的版本号和应答状态码； 服务器回应头信息 与浏览器端同理，服务器端也会将自身的信息发送一份至浏览器 服务器发送数据 在完成所有应答后，会以Content-Type应答头信息所描述的格式发送用户所需求的数据信息 断开TCP连接 在完成此次数据通信后，服务器会通过TCP四次挥手主动断开连接。但若此次连接为长连接，那么浏览器或服务器的头信息会加入keep-alive的信息，会保持此连接状态，在有其它数据发送时，可以节省建立连接的时间。 7. Http更快。 8. https证书加密的第一步是认证服务器。 一些主流浏览器会内置一个受信任的CA机构列表，并会保存相关CA机构的https证书。当用户在访问部署了https证书的网站时，服务器会提供经CA机构颁发的https证书，如果认证该服务器证书的CA机构是存在于浏览器的受信任CA机构列表当中，并且该https证书中的所有信息均与当前证在访问的网站所有信息一致，那么浏览器就会认为服务端是可信的，并从https证书中取得公钥（也就是CSR文件），用于后面的流程。 https证书加密的第二步是协商会话秘钥。 在服务器认证完获取公钥之后，利用公钥与服务器进行加密通信，协商出两个会话秘钥，用于加密客户端和加密服务端互发数据时的会话秘钥。这个秘钥是随机生成的，每一次协商产生的结果都不一样，所以安全性也是比较高的。 https证书加密的第三步是加密传输。 当客户端和服务器端都拥有了协商的会话密钥之后，进行数据传输时，都是以密文的方式进行传输。这样的传输方式，保证了数据的私密性和完整性，再也不用担心数据在传输过程中被第三者窃取和篡改了。 https证书加密完成这三步，就表示很完美的进行了一次数据加密传输。只要你申请的https证书是由受信任的CA机构（比如Symantec、Geotrust、Comodo以及RapidSSL等）颁发的，都可以保障网络的基本安全。 9. TCP是传输层协议，定义数据传输和连接方式的规范。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 HTTP 超文本传送协议(Hypertext Transfer Protocol )是应用层协议，定义的是传输数据的内容的规范。 HTTP协议中的数据是利用TCP协议传输的，特点是客户端发送的每次请求都需要服务器回送响应，它是TCP协议族中的一种，默认使用 TCP 80端口。 10. UDP 就可以识别在网络中的机器 11. 1、面向连接VS无连接TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手。另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放。UDP不需要建立连接，可以直接发起。 2、可靠VS不可靠TCP利用握手、ACK和重传机制，udp没有。（1）校验和（校验数据是否损坏）；（2）定时器（分组丢失则重传）；（3）序列号（用于检测丢失的分组和重复的分组）；（4）确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；（5）否定确认（接收方通知发送方未被正确接收的分组）；（6）窗口和流水线（用于增加信道的吞吐量）。（窗口大小：无需等待确认应答而可以继续发送数据的最大值） 3、有序性TCP利用seq序列号对包进行排序，udp没有。 4、面向字节流vs面向报文 （1）面向报文面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。（一个upd的最大报文长度2^16-1-20-8,20是ip报文头，8是udp报文头） （2）面向字节流面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。 5、tcp有流量控制，udp没有 6、tcp的头部比20bytes，udp8byres TCP应用场景：效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 UDP应用场景：效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。 UDP 要保证可靠，就依赖于重传 12. 1.慢开始 2.拥塞控制 3.快重传 4.快恢复 13. 简单的聊天功能、在线视频、网络语音电话 14. UDP要达到TCP的功能就必须实现拥塞控制的功能 15. 1、malloc与free是c++/c语言的标准函数，new/delete是C++的运算符。 2、他们都可用于申请动态内存和释放内存。new/delete比malloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。 既然new/delete的功能完全覆盖了malloc和free，为什么C++中不把malloc/free淘汰出局呢？因为c++程序经常要调用c函数，而c程序智能用malloc/free管理动态内存。 3、new返回指定类型的指针，并且可以自动计算出所需要的大小。如 ： int p; p = new int; //返回类型为int类型，大小为sizeof(int); int pa; pa = new int[50];//返回类型为int ，大小为sizeof(int) * 100; malloc必须用户指定大小，并且默然返回类型为void*,必须强行转换为实际类型的指针。 16. 1、new/delete是C++的操作符，而malloc/free是C中的函数。 2、new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。 3、new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。 4、new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。 17. 1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期） 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。 3.static的第三个作用是默认初始化为0（static变量） 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。 4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠） 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用： (1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。 (2)不能将静态成员函数定义为虚函数。 (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。 (4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过） (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。 (6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。 (7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） (8)静态成员初始化与一般数据成员初始化不同: 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符private，public等；初始化时使用作用域运算符来标明它所属类；所以我们得出静态数据成员初始化的格式：&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 18. 出现在类体外的函数定义不能指定关键字static；//static 是申明时候用的 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 静态成员函数不能访问非静态成员函数和非静态数据成员； 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式： ＜类名＞::＜静态成员函数名＞（＜参数表＞） 调用类的静态成员函数。 19. C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。 C++虚函数的底层实现原理 参考：https://blog.csdn.net/u011000290/article/details/50498683 20. 常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。 为什么： 1.调用虚函数需要访问虚表，构造函数在调用前根本不存在虚表，这带来了先有鸡还是先有蛋的问题；2.多态是根据指针指向的具体对象类型调用对应的方法，前提当然是这个对象是已经构建出来了；3.构造函数是定义一个对象时自动调用的，用户不能自己调用构造函数，所以没必要是虚函数；","categories":[],"tags":[]},{"title":"","slug":"不装了！！我们摊牌了！！我们是最全的内推，国内外所有大厂都可以内推！！（持续更新中）","date":"2020-10-07T16:58:52.362Z","updated":"2020-10-10T17:16:55.188Z","comments":true,"path":"2020/10/08/不装了！！我们摊牌了！！我们是最全的内推，国内外所有大厂都可以内推！！（持续更新中）/","link":"","permalink":"http://yoursite.com/2020/10/08/不装了！！我们摊牌了！！我们是最全的内推，国内外所有大厂都可以内推！！（持续更新中）/","excerpt":"​对公众号“扶摇就业”关注，选择”设为置顶or星标”第一时间你将了解更多实习 校招 社招 内推信息以及大厂面经 也欢迎各位大佬投递内推。 快来领取内推特权，投递简历哦！ 更多秋招内推：见本文下方推荐 秋招大战已然火热来袭！ 秋招过程中需要帮助，直接添加微信私聊！ 不论是求职方向迷茫，还是简历不知道如何完善，直接私聊！ 我们可能做不到最专业，但是一定做到最用心！","text":"​对公众号“扶摇就业”关注，选择”设为置顶or星标”第一时间你将了解更多实习 校招 社招 内推信息以及大厂面经 也欢迎各位大佬投递内推。 快来领取内推特权，投递简历哦！ 更多秋招内推：见本文下方推荐 秋招大战已然火热来袭！ 秋招过程中需要帮助，直接添加微信私聊！ 不论是求职方向迷茫，还是简历不知道如何完善，直接私聊！ 我们可能做不到最专业，但是一定做到最用心！扶摇就业，致力于为每一位勇敢追梦求职的同学 提供最nice的帮助！ 秋招内推答疑群 另外，我们近期针对21届的同学成立了秋招内推答疑群，有腾讯/阿里/百度/字节/华为等名企的往年秋招笔试面试资料，还有会更新每天公众号的文章内推，欢迎大家添加扶摇就业工作人员微信进群~（备注：秋招群） ​往期内推推荐：猿辅导内推｜首年薪资保底30w！面向20/21届！猿辅导2021教学教研岗招聘来了！上海银行内推｜上海银行2021届校园招聘开启，抓紧投递！招聘丨华泰证券2021校园招聘全球启动！招聘｜2021届校招西门子招聘 |建世界 投未来 ，中信建投2021届财富管理人才校园招聘-全国开启！招聘 | 国家外汇管理局中央外汇业务中心2021校园招聘招聘 | 2021届中国铁建校园招聘来了！招聘| 华能核电2021届校招蓝光发展内推｜高薪好福利，蓝光发展2021届校招正式启动！TCL实业内推｜TCL实业2021届校园招聘正式启动ONES内推（复临科技）｜ONES（复临科技）2021校园招聘正式启动啦！招聘｜中国航油2021校园招聘正式开启！招聘|中铁科建2021届校园招聘招聘｜东方电气集团2021校园招聘正式启动！（同时面向2020届）招聘 | 中国煤科2021年校园招聘启动！中国移动内推｜中国移动广东公司2021年秋季校园招聘火热启动！招聘｜中国海油2021届校园招聘招聘 | 新华保险2021校园招聘正式启动招聘｜三星(中国)半导体2021校园招聘保利发展控股2021校园招聘天津站即将开启世界品牌500强 | 特斯拉2021校园招聘正式启动！招聘 | 中国信科2021届校园招聘正式启动新城内推｜地产8强—新城控股2021新睿校园招聘正式启动西南旭辉内推| 西南旭辉2021届皓月生精英招募计划开启！同诚众悦地产内推｜同诚众悦地产集团2021新同学校招开启！微软社招内推校园招聘｜中国兵器工业集团2021届校招！校园招聘｜中国电子科技集团公司2021届校园招聘瑛太莱内推｜瑛太莱2021秋招来啦招聘｜国投集团2021年度校园招聘开启（同时面向2020届）招聘｜国信集团2020年集中招聘全面开启“邮”你“政”好！中国邮政2021年度联合校园招聘正式开启！招聘｜WO未来 G刻出发 ， 中国联通2021校园招聘正式启动！广发银行内推|广发银行2021年校园招聘正式启动百度社招内推京东社招内推 | 京东10月内推重点职位金地集团内推丨金地集团二〇二一校园招聘正式启动快看世界内推（快看漫画内推）｜科技撞破次元壁——快看世界2021校园招聘！中信银行内推 ▏中信银行信用卡中心2021届校园招聘正式启动！地平线内推｜地平线2021秋季校园招聘火热进行中~深演智能内推｜业内TOP级发展平台，成长快，户口指标！深演智能2021校招来了！卓越教育内推｜卓越教育集团2021校园招聘开始啦贝壳找房内推｜超高薪酬、完善的培训体系、明确的晋升路径！贝壳找房2021届新房营销管培生校招正式启动！BIGO内推 | BIGO2021届校园招聘正式启动！和我们探索无限，定义未来！涂鸦智能内推｜六大类岗位，深圳/杭州两地可选，涂鸦智能2021届校招&amp;空宣火热进行中！乐鑫科技内推｜全球市占率第一的 Wi-Fi MCU 原厂，乐鑫科技 2021 秋招开启！信也科技内推｜信也科技校招开始啦京东智联云内推 | 加入京东智联云|热门岗位 等你来投奥比中光内推｜六大类岗位，待遇优渥！奥比中光2021校招开始啦！凯媒通讯内推｜凯媒通讯校招全面开始啦合景泰富内推｜合景泰富集团2021校园招聘正式启动！科大讯飞内推｜科大讯飞2020届校园返场招聘来啦！盒子科技内推｜盒你一起，乘风破浪！盒子科技2021校园招聘全面开启啦！作业帮内推｜作业帮2021辅导老师秋招正式启动，20/21届均可投递！中移互联网内推（中国移动内推）｜中移互联网2021秋季校园招聘全面启动！中金所内推｜中金所技术公司2021届校招—9月11日开考！华数内推｜华数传媒控股股份有限公司2021届校园招聘阿里健康内推｜阿里健康2021届毕业生招聘正式启动歌莉娅内推｜歌莉娅21校招精英管培生项目 ， 真香！月薪过万，还能边旅行边工作南京银行内推 | 南京银行2021届全球校园招聘正式启动农夫山泉内推 | 养生堂·农夫山泉2021校园招聘新华三内推 | 新华三集团2021届校园招聘平安银行内推 | 平安银行2021届校园招聘全球启动安德医智内推｜AI医疗人工智能公司安德医智（BioMind®）2021校园招聘全面启动了！开立医疗内推｜开立医疗2021校园招聘正式启动！eBay内推｜eBay2021届校园招聘正式开启！微盟内推 | 加入我“盟”，微盟2021校招开始啦，让商业变得更智慧英格尔内推｜求“职”信：2021届英格尔校园招聘浩鲸科技内推 | 浩鲸科技2021届校招信捷电气内推｜信捷电气2021届秋招来啦腾讯内推 | 腾讯2021校招FreeWheel内推 | FreeWheel2021校园招聘正式启动！SmartX内推｜SmartX 2021 校园招聘启动！旷视科技内推|旷视科技2021校园招聘全面启动广州速游内推｜广州速游2021秋季校园招聘开启啦深演智能内推 | 深演智能2021校招91Act内推｜91Act 2021秋季校园招聘正式启动中国移动苏州研发中心内推｜“苏小研，你招不招！~” ——中国移动苏州研发中心校园招聘开始啦光锥元科技内推｜广州光锥元信息科技有限公司2021校招内推开启联影医疗内推｜联影医疗2021届校园招聘开启！ARM内推｜“Arm中国2021校园招聘”正式上映！英特尔内推｜英特尔中国2021校园招聘，无任何加班 标准955香港置地内推丨香港置地秋招开始啦，四大职能专场宣讲会准备就绪老虎证券内推｜美港股券商老虎证券2021校园招聘正式开启啦，招聘研发类、产品类、运营类、法务类和合规类等岗位珍爱网内推｜珍爱网2021届秋招启动啦！！心动网络内推｜心动网络 × TapTap 2021届校园招聘正式开启！超参数科技内推｜最具潜力的游戏AI公司秋招来啦~CVTE内推又来啦｜CVTE秋招开始啦小马智行内推 | 小马智行Pony.ai 2021校招斑马AI课内推｜估值78亿美元猿辅导旗下，斑马AI课2021校园招聘开始啦！我乐家居内推｜我乐家居2021校招内推启动！新网银行内推新网银行校招开始啦宁波银行内推｜宁行职研社 ，如何选对第一份工作新东方内推｜寻找XIN上人，新东方在线2021秋季校园招聘启动！校招社招均可内推，965欢迎你德邦快递内推｜德邦快递2021届校园招聘—相信新生力量美菜内推|美菜2021校园招聘全面启动吉利内推码 | 吉利2021全球校园招聘正式开启，同路人不惧将来，迈步新世界！酷狗音乐内推｜2021届酷狗音乐校招正式启动！豆神教育内推 | 豆神教育2021校招开始啦瑞典利乐内推｜20/21可投，食品包装巨头，瑞典利乐校招启动！玄武科技内推｜玄武科技2021校园招聘正式启动！万兴科技内推｜万兴科技2021届全球校园招聘正式启动！得物内推｜得物App2021校园招聘正式开启！正高速增长的潮流电商生活社区，超多岗位开放！第四范式内推 | 第四范式2021校招正式启动！维谛技术内推｜维谛技术2021届秋季招聘正式启动！虹软科技内推 | 刚刚！虹软2021校招又open出4个校招职位……声网内推|声网校招全面开始啦数美科技内推｜AI无界，潜力无限，数美科技2021校园招聘正式启动！普华永道内推｜普华永道校园招聘已开启！普华永道Leaper帮大家内推啦～坚果内推｜20/21届都可投！自由打卡、内购福利、丰厚薪资！阿里系独角兽，坚果2021校招启动！高途课堂内推｜高途课堂2021秋季校招火热进行！途虎养车内推｜紧急！途虎养车秋招开始啦！参与内推，简历直接免筛选哦！小丑鱼科技内推｜小丑鱼科技2021届校招正式启动！猫眼娱乐内推｜猫眼娱乐2021校园招聘正式启动思谋科技内推｜！！！思谋科技招人，就差你了中国人寿内推｜官宣！中国人寿集团2021年度校园招聘开始啦！优刻得内推 | UCLOUD优刻得2021校招开始啦恒生内推｜恒生校园招聘来啦，市值千亿上市公司！比肩蚂蚁金服！超多诱人福利等你来！微保内推｜微保2021届校园招聘拍了拍你！微信事业群内推｜不限专业！腾讯微信事业群2021届校招开启！加入鹅厂的机会来啦！松果出行内推｜松果出行秋招内推来了！参与内推，简历直达内推人！！15-22薪，免费午餐晚餐零食下午茶莉莉丝游戏内推丨莉莉丝游戏2021校园招聘正式启动！Shopee内推｜Shopee校招火热来袭正荣地产内推 | 正荣地产2021届荣耀生校园招聘荣燃启动！融创中国内推｜房企百强TOP4 ，融创中国2021届校园招聘正式开启！金智教育内推｜金智教育2021届秋招内推开启！快速笔面，极速拿offer！猿辅导内推教学教研｜首年25w~50w，六险一金，20/21届可报，猿辅导教学教研专场来啦！链家秋招内推来啦完美日记母公司逸仙电商2021校园招聘内推珍爱网 | 2021届秋招内推来啦汇量科技 | 2021届校园招聘内推，快人一步拿offer！东原集团2021届校园招聘内推启动健合集团丨2021届校园招聘内推正式启动乐信|2021校园招聘内推来啦万科内推来啦丨万科2021新动力全球校园招聘正式启动！奥园内推｜中国奥园集团2021校园招聘正式启动顺网科技内推 | 顺网科技2021届校园招聘蘑菇街内推丨蘑菇街2021届秋季校园招聘正式启动广联达内推｜广联达集团2021届校园招聘远景能源内推｜『远景能源热招』全球项目管理与运营工程师中国银联内推｜面向20/21届！大型国企！多专业可投！中国银联2021秋招正式启动！诗悦网络内推｜内推直通笔试/面试！行业高薪+免费三餐+六险一金+带薪假期！诗悦网络2021校招来啦！强生内推｜强生2021校园招聘正式启动！OnePlus内推｜OnePlus 2021校园招聘来了！中国光大银行招聘｜技术岗超详细面试题，中国光大银行2021校园招聘正式启动！寒武纪内推 | 寒武纪2021届校招全面开启核桃编程内推｜弹性工作制！不定期团建！晋升机会贼多！核桃编程2021校园招聘火热开启！入职配电脑和手机零食水果、营养餐等着你！竞技世界内推｜竞技世界2021届校园招聘正式启动星辉游戏内推 | 星辉游戏2021届秋季校园招聘正式开始啦！字节跳动商业化内推｜字节跳动商业化2021校园招聘来啦～专属内推迈瑞医疗内推｜迈瑞医疗2021届校园招聘正式启动熵简科技｜熵简科技2021校园招聘火热来袭，高于同行的薪资水平 全方位贴心福利！锐捷科技内推｜捷校招空宣高能来袭，速来领取入场券！中国电信内推｜紧急！中国电信秋招内推来了来了他终于来了！参与内推，快人一步拿offer！中通快递内推｜五险一金、提供食宿、免费班车…中通快递2021届校招来袭！快上车！云从科技内推｜云从科技2021校园招聘正式启动联发科技内推｜联发科技2021届校园招聘正式启动，期待你的到来锐思科内推｜五险一金+年薪9万起+双休+餐补+车补+年假等福利，锐思科集团2021届校园招聘迅雷内推｜迅雷秋招内推来了！参与内推，快人一步拿offer！乐鑫科技内推｜内推直通笔试！全球领先的AloT芯片公司，乐鑫科技2021秋招正式开启！飞鱼科技内推｜六险一金，免息购房购车借款！1v1定制培养计划！飞鱼科技2021校招网申进行中！商汤科技内推｜来康康，商汤五大事业群热招ing!网易有道内推丨网易有道2021校招来袭！免费四餐、班车接送、住房贷款…超多福利等着你！友塔游戏内推｜友塔游戏(中国) 2021校招来袭！招商银行信用卡中心内推| 招商银行信用卡中心2021届校园招聘正式开启！乐元素内推｜乐元素2021届校园招聘正式启动！西山居内推|金山西山居游戏2021秋季校园招聘正式启动！阅文集团内推｜不限专业！腾讯旗下大厂！内推简历享特权！阅文集团2021届校招来袭！微众银行内推丨背靠腾讯的国内首家互联网银行，微众银行校招正式启动！ 东原集团内推｜东原集团2021届营销“新秀”校招启动！ 锐捷网络内推｜七险一金，全国有岗，锐捷网络2021届校园招聘全面启动！ 三棵树内推｜三棵树2020届营销岗校招！年薪10-100万！ 依图科技内推｜顶级薪酬，顶尖技术，顶尖人才，依图科技2021届校园招聘火热进行中！ 网龙网络内推｜年薪可达24W！中国互联网企业百强！！网龙网络2021届校招来啦！ 图森未来内推|图森未来校招全面来袭 Thoughtworks内推｜20/21届都可投递！Thoughtworks 2021秋招正式启动！ 蘑菇街内推丨蘑菇街2021届秋季校招正式启动 顺网科技内推｜顺网科技2021届校招&amp;空宣 便利蜂内推｜登“蜂”造极，做更好的自己——便利蜂2020年秋季校园招聘正式启动 光峰科技内推|2020光峰科技秋季校园招聘 基恩士内推｜年薪21w！19-21届可投！市值千亿美元、外出专车接送、周末双休，全球100强基恩士校招开启！ 曼伦内推 | 多地有岗，高于行业75%的薪酬水平，曼伦2021校招正式启动！ 科华恒盛内推｜突破科望，华彩新生，科华恒盛2021校园招聘正式启动！ 大发地产内推｜大发地产[启明星] 造星计划正式启动 中国移动产业研究院内推｜中国移动研究院2021校园招聘正式启动！ 神策数据内推 | 2021 校招——神策数据，数说未来 陌陌内推 |陌陌2021届校招启动，内推链接，免笔试，直达HR邮箱 巨人网络秋招内推｜紧急！使用内推链接，简历直接免筛选！ 哈啰出行内推｜哈啰出行秋招内推来了！参与内推，简历直达HR！ 阿里健康内推 | 阿里健康2021校招启动！ 英雄互娱内推｜面向20&amp;21届！英雄互娱秋招内推开始了！参与内推，简历直达HR！ 迅雷内推｜迅雷集团2021届校园招聘 步步高内推｜年薪12-30W！单人公寓+福利食堂+班车接送！步步高2021校招开启！ 联咏科技内推 | 联咏科技2021校招，亚洲第一大IC设计公司，期待你的到来~ 三七互娱内推｜开放史上最多岗位，海量机会，最高年薪35w！三七互娱2021校招&amp;空宣来袭！ 欢聚集团内推｜欢聚集团校招全面来袭 新浪微博内推｜新浪微博2021届秋季校招内推开始，9月9日截止，附内推码 蔚来内推| 蔚来2021届校园招聘正式启动! 绿盟科技内推｜绿盟科技2021校招提前批全面启动！ 富途证券内推｜富途证券2021秋招全面启动 帆软内推|帆软2021秋招正式启动啦！ 百度内推｜百度校招扩招40%！大幅增加不限专业产品岗位，等你来投！ 浪潮集团内推｜面向20-21届！全国500强、大型IT企业！浪潮集团校招启动！超多福利等你来！ 盛趣游戏内推丨盛趣游戏2021届校招网申正式开启！ 远景内推 | 远景2021届校招 小鹏汽车内推｜紧急！小鹏汽车秋招内推倒计时！使用内推码，快人一步拿offer！ 学而思内推 |学而思爱智康2021秋招正式启动啦！18城任选 内推 | 阿里云智能事业群 内推 | Aibee 2021校园招聘 时代中国内推｜时代中国校招火热来袭 招商银行内推｜招商银行·招银网络科技秋招内推第一批即将截止！参与内推，快人一步拿offer ! 疯狂游戏内推丨20-21可投，底薪30w+，疯狂游戏研发SP专场 搜狗内推｜业内高薪+超长带薪年假，搜狗2021搜狗内推｜校招进行时，参与推优，有机会直通面试！ 三只松鼠内推 | 三只松鼠2021届校招 CVTE内推｜CVTE拥抱每一份热爱 ，CVTE 2021校园招聘正式启动 紫光展锐内推 | 紫光展锐2021届校招 苏宁内推 |苏宁2021海外留学生招聘正式启动！ 京东方内推丨京东方2021全球校园招聘开启 中兴通讯内推 | 中兴通讯2021届校招 金山云内推|金山云2021届校园招聘正式启动（含内推通道，名额有限，预申从速） 趋势科技内推 | 趋势科技2021校园招聘正式启动 OPPO 内推| OPPO 2021届全球校园招聘正式启动 烽火通信内推 | 烽火通信2021年校园招聘提前批正式开启 同花顺内推 | 同花顺2021届校园招聘正式启动啦 平安健康保险校招内推｜校招火热来袭 平安科技内推｜全程线上拿offer，平安科技2021校园招聘火爆进行中！ 万徳内推｜大数据龙头逆势扩招! 万得2021校招正式启动 内推 | 焦点科技2021校招 内推深信服|年薪21-24w起！面向20/21届！包三餐！超长带薪假期、超完善培训，最佳雇主深信服校招开启！ 内推 | 多益网络2021届校招开始 内推 |【字节跳动】商业变现团队2021秋招火热进行中！只等你来！ 内推简历免筛选直达笔试，月薪10-25K！吉比特&amp;雷霆游戏2021届校园招聘火热进行中 内推 | 思杰2021校园招聘&amp;宣讲会 内推 | 大华股份2021届校园招聘 内推|触宝秋招！使用内推链接，快人一步拿offer！ 内推 | 英伟达2021校园招聘 内推｜美团秋招全面来袭 内推 | 趣加FunPlus2021届校招 内推 | 飞鱼科技2021校园招聘 内推| 华为京津东北地区2021届校园招聘全面启动，日程公布！ 内推内推，简历直达HR~ | SHEIN 2021届校招 内推内推，简历直达HR~ | SHEIN 2021届校招 稍后有内推福利 | 融360公司2021届校招启动 内推码福利 | 中南置地2021届校园招聘火热启动！ 部分城市内推｜笔试岗位免笔试，简历优先处理，新东方2021秋季校园招聘全面启动！ 内推｜六大方向岗位！薪资福利优渥！龙湖集团2021届仕官生校园招聘火热启动！ 内推 | 德州仪器TI 2021届校招，2019届2020届同时可报 内推 | 大行育菁，农穗筑梦：中国农业银行总行校招如约而至 内推丨度小满金融2021校园招聘正式启动 内推｜奇安信2021秋招启动！高配笔记本，免费三餐加夜宵 内推来袭 | 微软2021届校招 内推 | 平安科技2021届校招火热来袭 内推｜TP-LINK 2021届校园招聘正式启动! 校招 | 中国电科五十五所2021届校招 校招｜可投2个岗位，嘉银金科2021届校园招聘火热来袭 内推｜拼多多高薪招聘多个岗位！不强制加班、一年两次调薪机会~~ 内推 |vivo2021全球校园招聘正式启动！ 内推｜2000+岗位，面向20、21届，深信服2021届校园招聘正式启动 内推 | 中国电信2021校园招聘 内推 | 平安产险2021届校招 校招｜中国移动2021届校招 内推 | 去哪儿网2021秋季校园招聘火热开启 中国农业银行总行2021校园招聘启事|67人（天津） 内推免筛简历 | 完美世界2021校园招聘来了 内推|最右2021届校园招聘正式批启动！ 内推| 腾讯音乐娱乐 2021 校园招聘正式启动 ！ 【央企，可转正，提供一日三餐，可解决北京户口】中国电信研究院未来网络中心招聘实习生 交通银行2021校园招聘火热启动！ 校招 | 中航制造技术研究院 招聘|2020年中新天津生态城教育系统教师（应届生）招聘21人公告 内推免筛｜快手2021校园招聘启动 内推免筛简历｜百度2021届校招全面启动！ 内推免筛简历 |字节跳动2021秋季校园招聘，教育专场正式启动！ 京东2021年校园招聘启动啦！内推免简历筛选！直通笔试！ 内推码｜小红书2021校园招聘正式启动！ 内推码｜2021届校园招聘百词斩秋招正式开启15薪！餐补+健身年卡 各种福利~！6大岗位招聘 月底截止~ 内推｜中国农业银行研发中心2021年校园招聘启事 内推｜股权激励，福利补贴MAX，还有杭州人才补贴！物联网科技大厂海康威视21届校招内推来了！ 8月15日天津市海河英才专场招聘会通知 限时内推｜众安保险2021届秋招开始啦！ 内推 | 360集团2021校园招聘正式启动！ 校园招聘 | 拼多多2021届校招提前批正式启动！ 内推| 跟谁学A+计划2021届秋季校园招聘会 内推｜贝壳找房2021届校园招聘正式启动 内推 | 小米集团2021全球校园招聘 滴滴2021校招，现已全面启动！|可内推 招聘 | 亚马逊中国2021校园招聘正式启动！ 校招 | 招行·招银网络科技2021校招 中国农业银行研发中心2021年校园招聘启事 内推｜哔哩哔哩2021秋招正式开启！内推优先筛选，可免笔试直通面试！史上最多岗位开放！ 爱奇艺2021校招启动！可内推！ 2021届网易校招全面来袭！｜有内推码 字节跳动2021届校园招聘秋招正式批火热来袭！！ 招聘 | 美团2021届秋季校园招聘全面启动 校园招聘 | 虎牙2021届校园招聘全面开启！ 20/21届校招均可投递|中国银行2021年全球校园招聘全面启动！ 内推|学而思网校校园招聘火热进行中！ 内推 | 58同城2021届校园招聘正式启动","categories":[],"tags":[]},{"title":"","slug":"关于企业进销存系统的分析","date":"2019-12-27T07:22:45.235Z","updated":"2020-05-14T08:10:10.687Z","comments":true,"path":"2019/12/27/关于企业进销存系统的分析/","link":"","permalink":"http://yoursite.com/2019/12/27/关于企业进销存系统的分析/","excerpt":"企业进销存管理系统 目录第一章 绪论1.1 开发背景及意义…………………………….11.2 国内外研究现状…………………………….11.3 研究内容和方法…………………………….2","text":"企业进销存管理系统 目录第一章 绪论1.1 开发背景及意义…………………………….11.2 国内外研究现状…………………………….11.3 研究内容和方法…………………………….21.3.1 研究内容………………………………21.3.2 研究方法………………………………2第二章需求分析……………………………………32.1 系统功能需求………………………………3 2.2 系统性能需求……………………………….5 2.3 可行性分析…………………………………5第三章 总体设计…………………………………..73.1 软件结构设计………………………………73.1.1 系统实现关系图………………………..73.1.2 系统功能模块设计……………………….73.2系统数据库设计……………………………..73.2.1 数据库概述…………………………….8 3.2.2 实体E-R图…………………………….8 3.2.3数据库表设计……………………………9 3.2.4数据库代码设计…………………………17 3.3.界面设计…………………………………173.3.1 登录界面……………………………..17 3.3.2 功能主界面……………………………19 3.4.输入输出设计……………………………..21 3.5安全密保设计……………………………..21第四章详细设计………………………………….224.1基础信息模块设计…………………………..224.1.1客户信息管理…………………………..224.1.2商品信息管理…………………………..234.1.3供应商信息管理…………………………244.2 进货管理模块设计………………………….254.2.1 进货单……………………………….254.2.2 进货退货……………………………..264.3 销售管理模块设计………………………….264.3.1销售单……………………………….264.3.2销售退货……………………………..274.4 查询统计模块设计………………………….284.4.1客户查询……………………………..284.4.2商品查询……………………………..284.4.3供应商查询…………………………….294.4.4销售查询……………………………..294.4.5销售退货查询…………………………..304.4.6入库查询………………………………304.4.7入库退货查询…………………………..314.4.8销售排行………………………………314.5 库存管理模块设计………………………….324.5.1库存盘点……………………………..324.5.2价格调整……………………………..324.6系统管理模块设计………………………….334.6.1用户管理……………………………..334.6.2更改密码……………………………..344.6.3权限管理……………………………..35第五章结论……………………………………..35 第一章 绪论1.1 开发背景及意义计算机技术的出现，使人类的生产力有了质的飞跃。计算机技术的出现促成了信息集成化的高度发展，由此进入了知识的经济时代。在知识经济时代，管理信息系统成为企业的生产和运作不可或缺的管理工具。管理信息系统是一门新的学科，它跨越了管理科学、系统工程学、运筹学、统计学和计算机科学等，在企业中起到了越来越重要的作用。我国的中小型企业众多，它在我国的经济发展中占有重要的地位。我国的中小企业数量多、分布广、行业跨、度大。它面临着国内大型生产企业以及国外进口商品和服务的严峻挑战。国内的大型国企央企及外资企业有着国内中小企业没有的大量的资金、丰富的管理经验、先进的技术手段和雄厚的政治资源。而且国内的大型国企央企及外资企业已经将类似于ERP这样的信息管理系统应用在实际生产中。现状对于中小企业的竞争非常不利。推出这样一套集成化程度高，扩展自由灵活的进销存管理系统，比较符合中小企业的需求。较短地开发周期降低了开发成本，也降低了中小企业信息化管理的费用。在市场经济中，销售是企业运作的重要环节之一。现在的大部分企业销售网络广，分布在各个省市之间，传统的人工传递信息显然已经不适合这个时代的经济发展。本课题通过先进的技术手段把进销存管理系统引入现代企业的信息管理中，通过技术手段把企业每天产生的大量抽象数据转化为直观可见的信息，为企业的决策者提供了真实可靠的决策依据。 1.2 国内外研究现状国外目前做的进销存管理系统，虽然现在产品都已经相对成熟，（国外情况具体化）但是由于中西文化的差异的存在，进销存管理系统中的财务管理等模块根本无法在企业中使用。国外的财务管理流程跟国内的差距很大。比如说，在国外的财务管理中应收账款和增值税发票是放在一起进行管理的，但是在国内，绝大部分企业都是先产生应收的帐款，然后再进行开票。而且，有时候需要把几笔应收的帐款合在一起进行增值税发票开票。如果把增值税发票纳入营收账款进行管理的话，财务人员便无法对财务流程进行正确操作。而且很多税务报表有由国家财务税务部门的统一标准。据目前从网上可以查得到的信息显示，目前国内存在的进销存管理系统花样繁多。比如美萍商业进销存管理系统 9.7，其中包含有商品销售管理系统，库存管理系（仓库管理系统）。系统界面简洁，操作简单，用户可以轻松上手。由于系统基于C/S结构，大量的冗余数据存储在本地，数据无法得到实时得更新，而且无论从数据的角度还是版本升级的角度来讲，本地更新的代价都相对较大。 1.3 研究内容和方法1.3.1 研究内容主要包括以下功能模块：1.管理员管理模块：主要包括管理员登录、查看管理员列表、添加管理员信息、管理员权限设置、删除管理员和更改口令等。2.进货管理模块：主要包括填写进货单、查看进货信息、查看退货信息等。3.基础信息管理模块：主要包括客户信息添加、客户信息的修改和删除、商品信息添加、商品信息的修改与删除、供应商信息添加、供应商信息的修改与删除等。4.库存管理模块：主要包括库存盘点、库存价格调整等。1.3.2 研究方法查找资料，本系统实现的对各种繁多商品信息的增、删、改、查的功能完全满足的企业的日常需求。系统最大限度地实现了易使用性、易维护性。系统运行稳定，安全可靠。界面简洁友好，操作简单灵活。实施规范的进、销、存一体化业务管理。强大的查询分析功能。灵活、细分的权限控制功能（待实现）。本系统是一款将进货、销售、库存进行一体化管理的系统。由供应商管理、商品管理、入库管理、库存管理、销售管理、款项管理和系统管理（待实现）等模块组成。 第二章 需求分析2.1 系统功能需求根据企业进销存管理系统的特点，将系统分为六大模块：进货管理、基础信息管理、销售管理、库存管理、查询统计、系统管理。 企业进销存管理系统的功能结构图如图所示： 进销业务流程如图所示： 运营管理实体联系图如下： 2.2 系统性能需求根据前面所作的需求分析及功能的需求可以得出，进销存管理系统实施后，应达到以下系统性能标准。（1）系统窗体设计要求美观大方、功能全面、操作简单；（2）系统整体结构和操作流程合理顺畅，实现人性化设计；（3）对操作员设置不同的操作权限，为管理员提供修改权限功能；（4）对所有商品进行集中管理；（5）对销售信息提供销售排行；（6）支持销售退货和入库退货功能；（7）支持库存价格调整功能；（8）为了方便用户，要求系统支持多条件查询；（9）当外界环境（停电、网络病毒）干扰本系统时，系统可以自动保护原始数据的安全；（10）为操作员提供密码修改功能；（11）系统运行稳定、安全可靠。 2.3 可行性分析根据《GB8567-88 计算机软件产品开发文件编制指南》中可行性分析的要求，制定可行性研究报告如下。 1.引言（1）编写目的：以文件的形式给企业的决策层提供项目实施的参考依据，其中包括项目存在的风险、项目需要的投资和能够收获的最大效益。（2）背景：本公司是一家以商业经营为主的私有企业。为了完善管理制度、增强企业的竞争力、实现信息化管理，公司决定开发进销存管理系统。 2.可行性研究的前提（1）要求：企业进销存管理系统必须提供商品信息、供应商信息和客户信息的基础设置; 提供强大的多条件搜索功能和商品的进货、销售和库存管理功能; 可以分不同权限、不同用户对该系统进行操作。另外，该系统还必须保证数据的安全性、完整性和准确性。（2）目标： 企业进销存管理系统的目标是实现企业的信息化管理，减少盲目采购、降低采购成本、合理控制库存、减少资金占用并提升企业市场竞争力。（3）条件、假定和限制： 为实现企业的信息化管理，必须对操作人员进行培训，并将原有的库存、销售、入库等信息转换为信息化数据，需要操作员花费大量时间和精力来完成。为了不影响企业的正常运行，进销存管理系统必须在两个月的时间内交付用户使用。系统分析人员需要2 天内到位，用户需要S 天时间确认需求分析文档。去除其中可能出现的问题，如用户可能临时有事，占用6 天时间确认需求分析。那么程序开发人员需要在1个月零15 天的时间内进行系统设计、程序编码、系统测试、程序调试和网站部署工作。期间，还包括了员工每周的休息时间。（4）评价尺度： 根据用户的要求，项目主要以企业进货、销售和查询统计功能为主，对于库存、销售并提供相应的查询和统计。由于库存商品数量和进货的记录信息应该及时、准确地保存，太多，不易盘点，传统的盘点方式容易出错，系统中的库存盘点功能要准确地计算出每种商品的损益数量，减少企业不必要的损失。 3.投资及效益分析（1）支出： 为此，公司将根据系统的规模及项目的开发周期(两个月),公司决定投入7 个人。直接支付9 万元的工资及各种福利待遇。在项目安装及调试阶段，用户培训、员工出差等费用支出需要2 万元。在项目维护阶段预计需要投入4万元的资金。累计项目投入需要15万元资金。（2）收益： 用户提供项目资金32 万元。对于项目运行后进行的改动，采取协商的原则根据改动规模额外提供资金。因此从投资与收益的效益比上，公司可以获得18 万元的利润。项目完成后，会给公司提供资源储备，包括技术、经验的积累，其后再开发类似的项目时，可以极大地缩短项目开发周期。 4.结论 根据，上面的分析，在技术上不会存在问题，因此项目延期的可能性很小。在效益上公司投入7 个人、2 个月的时间获利18万元，效益比较可观。在公司今后发展上，可以储备网站开发的经验和资源。因此认为该项目可以开发。 第三章总体设计3.1 软件结构设计系统总体结构设计是根据系统分析的要求和组织的实际情况来对新系统的总体结构形式进行大致设计，它是一种宏观、总体上的设计和规划。 3.1.1 系统实现关系图进销存管理系统的系统流程图如图所示： 3.1.2 系统功能模块设计 经实际考察分析、基于企业发展需求，现将进销存管理系统按照功能划分为基础信息管理、进货管理、销售管理、库存管理、查询统计和系统管理6大部分。基础信息模块主要用于实现客户信息管理、商品信息管理、供应商信息管理等过程；进货管理模块主要用于实现订制进货单、统计进货退货信息等过程；销售管理模块主要实现订制销售单、统计销售退货信息等过程；库存管理模块主要实现库存盘点、库存价格调整等过程；查询统计模块主要用于实现客户查询、供应商查询、销售排行等功能。系统管理模块主要用于操作管理员、修改密码、权限管理等功能。 3.2系统数据库设计3.2.1 数据库概述 对于数据库应用开发人员来说，为使现实世界的信息流计算机化，并对计算机化的信系统软件和相关硬件系统，将用户的信息进行各种操作，就是如何利用数据库管理系统、求转换成有效的数据结构，并使数据结构易于实现用户新的要求的过程。确切地说，数据库设计是指对于一个给定的应用环境，提供1 ~n个确定最优数据模型与处理模式的逻辑设计，以及一个确定数据库存储结构与存取方法的物理设计，建立起既能反映现实世界信息和信息联系，满足用户数据要求和加工要求，又能被某个数据库管理系统所接受，同时能实现系统目标，并有效存取数据的数据库。系统的数据库定义模型如图所示： 3.2.2实体E-R图根据实际调查对系统所做的需求分析、系统设计，规划出本系统中使用的数据库实体分别为客户实体、供应商实体、商品实体等。下面将介绍几个关键实体的E-R 图。1.客户实体企业进销存管理系统将记录所有的客户信息，在执行销售、退货等操作时，将直接引用该客户的实体属性。客户实体包括客户编号、客户名称、简称、地址、电话、E-mail、邮政编码、联系人、联系电话、传真、开户行和账号等属性，客户实体E-R 图如图所示： 2.供应商实体不同的供应商可以为企业提供不同的商品，在商品信息中将引用商品供应商的实体属性。供应商实体包括编号、名称、简称、地址、电话、邮政编码、传真: 联系人、联系电话、开户行和E-mail属性等，供应商实体E-R图如下： 3.商品实体商品信息是进销存管理系统中的基本信息，系统将维护商品的进货、退货、销售、入库等操作。商品实体包括编号、名称、简称、产地、单位、规格、包装、批号、批准文号、商品简介和供应商属性，商品实体E-R图如下： 3.2.3数据库表设计结合实际情况及对用户需求的分析，进销存管理系统db.JXC 数据库主要包含如下图所示的数据表。 说明表：表明 说明tb gysinfo 供应商信息表tb khinfo 客户位息表tb xsth main 销售退货主表tb xsth detail 销传退货明细表tb userlist 用户信息表tb spinfo 商品信息表tb sellmai 销售主表：tb sell detail 销售明细表：tb rkth main 入库退货主表：tb rkth detail 入库退货明细表tb kucun 库存信息表 1.tb gysinfo（供应商信息表）不同的供应商可以为企业提供不同的商品，在商品信息中将引用商品供应商的实体属性。字段名 字段类型 是否允许为空 说明id Varchar(50) 否 编码name Varchar(50) 是 名称jc Varchar(50) 是 简称address Varchar(100) 是 地址bianma Varchar(50) 是 电话tel Varchar(50) 是 邮政编码fax Varchar(50) 是 传真lian Varchar(50) 是 联系人ltel Varchar(50) 是 联系电话yh Varchar(50) 是 开户行mail Varchar(50) 是 E-mail在数据库中数据库表设计如下： 2.tb khinfo（客户信息表）企业进销存管理系统将记录所有的客户信息，在执行销售、退货等操作时，将直接引用该客户的实体属性。字段名 字段类型 是否允许为空 说明id Varchar(50) 否 客户编号kname Varchar(50) 是 客户名称Jian Varchar(50) 是 简称adress Varchar(100) 是 地址bianma Varchar(50) 是 电话tel Varchar(50) 是 E-mailfax Varchar(50) 是 邮政编码lian Varchar(50) 是 联系人ltel Varchar(50) 是 联系电话mail Varchar(50) 是 传真xinhang Varchar(60) 是 开户行hao Varchar(60) 是 账号属性数据库中数据库表设计如下： 3.tb xsth main（销售退货主表）字段名 字段类型 是否允许为空 说明xsthID Varchar(30) 否 销售退货票号pzs int 否 品种数量je money 否 结算方式ysjl Varchar(50) 是 验收结论khname Varchar(100) 否 客户名称thdate datetime 否 退货时间czy Varchar(30) 否 操作人员jsr Varchar(30) 否 经手人jsfs Varchar(10) 否 结算方式在数据库中数据库表设计如下： 4.tb xsth detail（销售退货明细表）字段名 字段类型 是否允许为空 说明id int 否 编号xsthID Varchar(30) 否 销售编号spid Varchar(50) 否 商品编号dj money 否 单价sl int 否 数量在数据库中数据库表设计如下： 5.tb userlist（用户信息表）字段名 字段类型 是否允许为空 说明name Varchar(50) 否 姓名username Varchar(50) 否 登录名pass Varchar(50) 否 登录密码quan Varchar(2) 否 权限 在数据库中数据库表设计如下： 6.tb spinfo（商品信息表）商品信息是进销存管理系统中的基本信息，系统将维护商品的进货、退货、销售、入库等操作。字段名 字段类型 是否允许为空 说明id Varchar(50) 否 编号spname Varchar(50) 否 名称jc Varchar(50) 是 简称cd Varchar(50) 是 产地dw Varchar(50) 是 单位gg Varchar(50) 否 规格bz Varchar(50) 否 包装ph Varchar(50) 是 批号pzwh Varchar(50) 是 批准文号memo Varchar(50) 是 商品简介gysname Varchar(50) 是 供应商属性在数据库中数据库表设计如下： 7.tb sellmai （销售主表：）字段名 字段类型 是否允许为空 说明sellID varchar(30) 否 销售票号pzs int 否 品种数量je money 否 结算方式ysjl varchar(50) 是 验收结论khname varchar(100) 否 客户名称xsdate datetime 否 退货时间czy Varchar(30) 否 操作人员jsr Varchar(30) 否 经手人jsfs Varchar(10) 否 结算方式 在数据库中数据库表设计如下： 8.tb sell detail（销售明细表：）字段名 字段类型 是否允许为空 说明id int 否 编号sellID varchar(30) 否 销售编号spid varchar(30) 否 商品编号dj money 否 单价sl float 否 数量 在数据库中数据库表设计如下： 9.tb rkth main（入库退货主表：）字段名 字段类型 是否允许为空 说明rkthID varchar(30) 否 入库退货票号pzs float 否 品种数量je money 否 结算方式ysjl varchar(50) 是 验收结论khname varchar(100) 否 客户名称rtdate datetime 否 退货时间czy varchar(30) 否 操作人员jsr varchar(30) 否 经手人jsfs varchar(10) 否 结算方式 在数据库中数据库表设计如下： 10.tb rkth detail（入库退货明细表）字段名 字段类型 是否允许为空 说明id int 否 编号rkthID varchar(30) 否 入库退货编号spid varchar(30) 否 商品编号dj money 否 单价sl float 否 数量 在数据库中数据库表设计如下： 11.tb kucun （库存信息表）字段名 字段类型 是否允许为空 说明id varchar(30) 否 商品编号spname varchar(50) 否 商品名称jc varchar(25) 是 时间cd varchar(50) 是 产地gg varchar(50) 是 规格bz varchar(50) 是 包装dw varchar(10) 是 单位dj money 是 单击kcsl int 是 数量 在数据库中数据库表设计如下： 对大多数应用系统而言，很大程度上都是围绕对数据库的操作展开的,数据库本身才是应用系统的核心部分，程序界面只是提供用户对数据库中的数据的组织与管理的接口。任何数据库结构的变更都很可能导致界面程序的改动。因此,数据库结构设计至关重要。 3.2.4数据库代码设计 代码是代表客观存在的实体或属性的符号，科学合理的代码，可以使计算机对数据的分类、校对、统计、查询等的处理变得简单快捷。本系统的代码设计的原则是: 代码要具有唯一性、标准化、方便，结构尽量简单,长度尽可能的短。以数据库设计中的几个表所涉及到的代码为例说明本系统的代码设计。系统多数代码设计采用无实意顺序码与实意日期编辑，由于产品进销存其关键的是时间，因代码编排采用时间顺序。而信息，生产厂商信息采用无实意的代码编辑。 3.3界面设计3.3.1登录界面1.界面分解：Login.java,LoginPanel.java 2.结构： 3.函数调用关系： 添加LoginPanel设置：public class LoginPanel extends JPanel { protected ImageIcon icon; public int width,height; public LoginPanel() { super(); icon = new ImageIcon(“res/login.jpg”); width = icon.getIconWidth(); height = icon.getIconHeight(); setSize(width, height); } protected void paintComponent(Graphics g) { super.paintComponent(g); Image img = icon.getImage(); g.drawImage(img, 0, 0,getParent()); }}Jbutton 监听，实现登录、退出功能：login = new JButton(); login.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent e) { user = Dao.getUser(userName.getText(), userPassword.getText()); if (user.getUsername() == null || user.getName() == null) { userName.setText(null); userPassword.setText(null); return; } setVisible(false); new JXCFrame(); } }); login.setText(“登录”); login.setBounds(180, 195, 60, 18); panel.add(login); exit = new JButton(); exit.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent e) { System.exit(0); } }); exit.setText(“退出”); exit.setBounds(260, 195, 60, 18); panel.add(exit); 3.3.2功能主界面1.界面分解：JXCFrame.java 2.结构： 3.函数调用关系： 4.事件响应：监听器// 窗体监听器 private final class FrameListener extends ComponentAdapter { public void componentResized(final ComponentEvent e) { updateBackImage(); } } // 主窗体菜单项的单击事件监听器 protected final class openFrameAction extends AbstractAction { private String frameName = null; private openFrameAction() { } public openFrameAction(String cname, String frameName, Icon icon) { this.frameName = frameName; putValue(Action.NAME, cname); putValue(Action.SHORT_DESCRIPTION, cname); putValue(Action.SMALL_ICON, icon); } public void actionPerformed(final ActionEvent e) { JInternalFrame jf = getIFrame(frameName); // 在内部窗体闭关时，从内部窗体容器ifs对象中清除该窗体。 jf.addInternalFrameListener(new InternalFrameAdapter() { public void internalFrameClosed(InternalFrameEvent e) { ifs.remove(frameName); } }); if (jf.getDesktopPane() == null) { desktopPane.add(jf); jf.setVisible(true); } try { jf.setSelected(true);}catch (PropertyVetoException e1) { e1.printStackTrace(); } } } static { try { UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); } catch (Exception e) { e.printStackTrace();} } 3.4输入输出设计 输入输出是用户与系统的重要的、直接的接口，企业日常运作而产生的原始数据要靠系统的输入完成，同时用户所需的各种信息、报表都要由系统的输出完成，所以输入输出设计对于系统将来的实际使用效果会产生很大影响。本系统的输入设计原则是本着保证处理需要的前提下尽量减少输入; 数据输入时要采取有效措施，以减少锴误的发生，输入方式以键盘输入为主。为避免输入时产生数据错误大部分输入采用系统自动生成，用户只要双击或者单击鼠标就能实现数据的插入或删除。本系统的输出设计原则是界面美观、数据准确，采用的输出方式主要以显示输出为主，同时在必要的地方采用打印输出。 3.5安全保密设计 本系统的保密功能通过用户的权限设定来实现。用户在登录系统时输入密码，如果密码正确，系统根据该用户的权限，设置该用户可以进行的操作。用户的权限设定是以系统的菜单项为基本单位，只有用户具有使用该菜单的权限时，菜单项才可以为其所用。当添加新用户时，用户的权限为空(即不能进行任何操作)。系统的数据安全通过数据备份与恢复的功能来实现，此时应为该用户设置相应权限;用户权限也可以根据具体情况随时修改。此外，为保证计算机的安全，每台计算机都加装了UPS不间断电源，保证在突然断电情况下能够正常退出系统。第四章详细设计4.1基础信息模块设计 主要包括客户管理、商品管理和供应商管理3部分，它们的作用与实现方法基本相似。对用户输入的数据，系统进行严格的数据检验，尽可能排除人为的错误。4.1.1客户信息管理选择“基础信息管理”/“客户信息管理”按钮，在弹出的窗体中进行对客户信息添加、修改以及删除操作。（1）客户信息添加主要负责为系统添加新的客户记录。在企业进销管理系统中，商品是主要的管理对象，而系统中的大部分商品都会向客户销售，这就需要把不同的客户信息添加到系统中，在商品信息中会关联系统中对应的客户信息。客户信息添加功能的程序界面如图所示： 如图所示，添加客户名为王小明的相关信息，数据库中表tb khinfo中会增添此条记录。主要实现函数如下：TbKhinfo khinfo = new TbKhinfo(); khinfo.setId(id); khinfo.setAddress(diZhi.getText().trim()); khinfo.setBianma(youZhengBianMa.getText().trim()); khinfo.setFax(chuanZhen.getText().trim()); khinfo.setHao(yinHangZhangHao.getText().trim()); khinfo.setJian(keHuJianCheng.getText().trim()); khinfo.setKhname(keHuQuanCheng.getText().trim()); khinfo.setLian(lianXiRen.getText().trim()); khinfo.setLtel(lianXiDianHua.getText().trim()); khinfo.setMail(EMail.getText().trim()); khinfo.setTel(dianHua.getText().trim()); khinfo.setXinhang(kaiHuYinHang.getText()); Dao.addKeHu(khinfo); JOptionPane.showMessageDialog(KeHuTianJiaPanel.this, “已成功添加客户”, “客户添加信息”, JOptionPane.INFORMATION_MESSAGE); resetButton.doClick();手动输入到类型为JTextField的对象diZhi、youZhengBianMa、chuanZhenyinHangZhangHao、keHuJianCheng、keHuQuanCheng、lianXiDianHua、EMail、dianHua、kaiHuYinHang中，然后调用Dao类中定义函数的addKeHu（），将此条数据添加入库。（2）客户信息修改与删除 客户信息修改与删除主要用于维护系统中的客户信息。在客户地址、客户简称、邮政编码、电话、传真、联系人、联系电话、Email、开户银行和银行账户任一发生改变时，必须更新系统中的记录，以提高客户的最新信息。另外，当不再与某客户发生交易时，需要从系统中删除该客户的记录信息。程序运行界面如图所示： 所有修改与删除操作为通过Dao类中定义的函数updateKeHu()实现，主要函数包含在KeHuXiuGaiPanel.java中。主要实现函数如下：处理删除按钮的单击事件 delButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Item item = (Item) kehu.getSelectedItem(); if (item == null || !(item instanceof Item)) return; int confirm = JOptionPane.showConfirmDialog( KeHuXiuGaiPanel.this, “确认删除客户信息吗？”); if (confirm == JOptionPane.YES_OPTION) { int rs = Dao.delete(“delete tb_khinfo where id=’” + item.getId() + &quot;&apos;&quot;); if (rs &gt; 0) { JOptionPane.showMessageDialog(KeHuXiuGaiPanel.this, &quot;客户：&quot; + item.getName() + &quot;。删除成功&quot;); kehu.removeItem(item); } } } }); 处理修改按钮的单击事件 modifyButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Item item = (Item) kehu.getSelectedItem(); TbKhinfo khinfo = new TbKhinfo(); khinfo.setId(item.getId()); khinfo.setAddress(diZhi.getText().trim()); khinfo.setBianma(youZhengBianMa.getText().trim()); khinfo.setFax(chuanZhen.getText().trim()); khinfo.setHao(yinHangZhangHao.getText().trim()); khinfo.setJian(keHuJianCheng.getText().trim()); khinfo.setKhname(keHuQuanCheng.getText().trim()); khinfo.setLian(lianXiRen.getText().trim()); khinfo.setLtel(lianXiDianHua.getText().trim()); khinfo.setMail(EMail.getText().trim()); khinfo.setTel(dianHua.getText().trim()); khinfo.setXinhang(kaiHuYinHang.getText()); if (Dao.updateKeHu(khinfo) == 1) JOptionPane.showMessageDialog(KeHuXiuGaiPanel.this, “修改完成”); else JOptionPane.showMessageDialog(KeHuXiuGaiPanel.this, “修改失败”); } }); }4.1.2商品信息管理选择“基础信息管理”/“商品信息管理”按钮，在弹出的窗体中进行对商品信息添加、修改以及删除操作。（1）商品信息添加 如图所示，添加商品信息名为圆纹小提琴的相关信息，数据库中表tb spinfo中会增添此条记录。添加商品信息：TbSpinfo spInfo = new TbSpinfo(); spInfo.setId(id); spInfo.setBz(baoZhuang.getText().trim()); spInfo.setCd(chanDi.getText().trim()); spInfo.setDw(danWei.getText().trim()); spInfo.setGg(guiGe.getText().trim()); spInfo.setGysname(gysQuanCheng.getSelectedItem().toString() .trim()); spInfo.setJc(jianCheng.getText().trim()); spInfo.setMemo(beiZhu.getText().trim()); spInfo.setPh(piHao.getText().trim()); spInfo.setPzwh(wenHao.getText().trim()); spInfo.setSpname(quanCheng.getText().trim()); Dao.addSp(spInfo); JOptionPane.showMessageDialog(ShangPinTianJiaPanel.this, “商品信息已经成功添加”, “商品添加”, JOptionPane.INFORMATION_MESSAGE); resetButton.doClick();重添按钮的事件监听类 resetButton = new JButton(); setupComponent(tjButton, 3, 8, 1, 1, false); resetButton.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent e) { baoZhuang.setText(“”); chanDi.setText(“”); danWei.setText(“”); guiGe.setText(“”); jianCheng.setText(“”); beiZhu.setText(“”); piHao.setText(“”); wenHao.setText(“”); quanCheng.setText(“”); } }); resetButton.setText(“重添”);手动输入到类型为JTextField的对象baoZhuang、chanDi、danWei、guiGe、gysQuanCheng、jianCheng、beiZhu、piHao、wenHao、quanCheng中，然后调用Dao类中定义函数的addSp（），将此条数据添加入库。 （2）商品信息修改与删除 所有修改与删除操作为通过Dao类中定义的函数updateSp()实现，主要函数包含在ShangPinXiuGaiPanel.java中。定位商品信息的下拉选择框 setupComponet(sp, 1, 8, 2, 0, true); modifyButton = new JButton(“修改”); delButton = new JButton(“删除”); JPanel panel = new JPanel(); panel.add(modifyButton); panel.add(delButton);处理删除按钮的单击事件 delButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Item item = (Item) sp.getSelectedItem(); if (item == null || !(item instanceof Item)) return; int confirm = JOptionPane.showConfirmDialog( ShangPinXiuGaiPanel.this, “确认删除商品信息吗？”); if (confirm == JOptionPane.YES_OPTION) { int rs = Dao.delete(“delete tb_spinfo where id=’” + item.getId() + &quot;&apos;&quot;); if (rs &gt; 0) { JOptionPane.showMessageDialog(ShangPinXiuGaiPanel.this, &quot;商品：&quot; + item.getName() + &quot;。删除成功&quot;); sp.removeItem(item); } } } }); 处理修改按钮的单击事件 modifyButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Item item = (Item) sp.getSelectedItem(); TbSpinfo spInfo = new TbSpinfo(); spInfo.setId(item.getId()); spInfo.setBz(baoZhuang.getText().trim()); spInfo.setCd(chanDi.getText().trim()); spInfo.setDw(danWei.getText().trim()); spInfo.setGg(guiGe.getText().trim()); spInfo.setGysname(gysQuanCheng.getSelectedItem().toString() .trim()); spInfo.setJc(jianCheng.getText().trim()); spInfo.setMemo(beiZhu.getText().trim()); spInfo.setPh(piHao.getText().trim()); spInfo.setPzwh(wenHao.getText().trim()); spInfo.setSpname(quanCheng.getText().trim()); if (Dao.updateSp(spInfo) == 1) JOptionPane.showMessageDialog(ShangPinXiuGaiPanel.this, “修改完成”); else JOptionPane.showMessageDialog(ShangPinXiuGaiPanel.this, “修改失败”); } }); }4.1.3供应商信息管理选择“基础信息管理”/“供应商信息管理”按钮，在弹出的窗体中进行对供应商信息添加、修改以及删除操作。（1）供应商信息添加 如图所示，添加供应商全称名为RF食品有限公司的相关信息，数据库中表tb gysinfo中会增添此条记录。GYsTianjiaPanel.javatry { ResultSet haveUser = Dao .query(“select * from tb_gysinfo where name=’” + quanChengF.getText().trim() + &quot;&apos;&quot;); if (haveUser.next()) { JOptionPane.showMessageDialog(GysTianJiaPanel.this, &quot;供应商信息添加失败，存在同名供应商&quot;, &quot;供应商添加信息&quot;, JOptionPane.INFORMATION_MESSAGE); return; } ResultSet set = Dao.query(&quot;select max(id) from tb_gysinfo&quot;); String id = null; if (set != null &amp;&amp; set.next()) { String sid = set.getString(1).trim(); if (sid == null) id = &quot;gys1001&quot;; else { String str = sid.substring(3); id = &quot;gys&quot; + (Integer.parseInt(str) + 1); } } TbGysinfo gysInfo = new TbGysinfo(); gysInfo.setId(id); gysInfo.setAddress(diZhiF.getText().trim()); gysInfo.setBianma(bianMaF.getText().trim()); gysInfo.setFax(chuanZhenF.getText().trim()); gysInfo.setYh(yinHangF.getText().trim()); gysInfo.setJc(jianChengF.getText().trim()); gysInfo.setName(quanChengF.getText().trim()); gysInfo.setLian(lianXiRenF.getText().trim()); gysInfo.setLtel(lianXiRenDianHuaF.getText().trim()); gysInfo.setMail(EMailF.getText().trim()); gysInfo.setTel(dianHuaF.getText().trim()); Dao.addGys(gysInfo); JOptionPane.showMessageDialog(GysTianJiaPanel.this, &quot;已成功添加供应商&quot;, &quot;添加供应商信息&quot;, JOptionPane.INFORMATION_MESSAGE); resetButton.doClick(); } catch (SQLException e1) { e1.printStackTrace(); 手动输入到类型为JTextField的对象diZhiF、bianMaF、chuanZhenF、yinHangF、jianChengF、quanChengF、lianXiRenF、lianXiRenDianHuaF、EMailF、dianHuaF中，然后调用Dao类中定义函数的addGys（），将此条数据添加入库。 （2）供应商信息修改与删除 所有修改与删除操作为通过Dao类中定义的函数updateGys()实现，主要函数包含在GysXiuGaiPanel.java中。定位供应商信息的下拉选择框 setupComponet(gys, 1, 7, 2, 0, true); JButton modifyButton = new JButton(“修改”); JButton delButton = new JButton(“删除”); JPanel panel = new JPanel(); panel.add(modifyButton); panel.add(delButton);修改按钮的事件监听器 class ModifyActionListener implements ActionListener { public void actionPerformed(ActionEvent e) { Item item = (Item) gys.getSelectedItem(); TbGysinfo gysInfo = new TbGysinfo(); gysInfo.setId(item.getId()); gysInfo.setAddress(diZhiF.getText().trim()); gysInfo.setBianma(bianMaF.getText().trim()); gysInfo.setFax(chuanZhenF.getText().trim()); gysInfo.setYh(yinHangF.getText().trim()); gysInfo.setJc(jianChengF.getText().trim()); gysInfo.setName(quanChengF.getText().trim()); gysInfo.setLian(lianXiRenF.getText().trim()); gysInfo.setLtel(lianXiRenDianHuaF.getText().trim()); gysInfo.setMail(EMailF.getText().trim()); gysInfo.setTel(dianHuaF.getText().trim()); if (Dao.updateGys(gysInfo) == 1) JOptionPane.showMessageDialog(GysXiuGaiPanel.this, “修改完成”); else JOptionPane.showMessageDialog(GysXiuGaiPanel.this, “修改失败”); } }删除按钮的事件监听器 class DelActionListener implements ActionListener { public void actionPerformed(ActionEvent e) { Item item = (Item) gys.getSelectedItem(); if (item == null || !(item instanceof Item)) return; int confirm = JOptionPane.showConfirmDialog( GysXiuGaiPanel.this, “确认删除供应商信息吗？”); if (confirm == JOptionPane.YES_OPTION) { int rs = Dao.delete(“delete tb_gysInfo where id=’” + item.getId() + &quot;&apos;&quot;); if (rs &gt; 0) { JOptionPane.showMessageDialog(GysXiuGaiPanel.this, &quot;供应商：&quot; + item.getName() + &quot;。删除成功&quot;); gys.removeItem(item); } else { JOptionPane.showMessageDialog(GysXiuGaiPanel.this, &quot;无法删除客户：&quot; + item.getName() + &quot;。&quot;); } } 4.2 进货管理模块设计进货管理模块主要包括进货单、进货退货2部分。4.2.1 进货单选择“进货管理”/“进货单”按钮，在弹出的窗体中进行添加进货单、商品入库信息操作。进货单主要用于向系统中添加进货信息。可设置并存储进货票号、供应商、联系人、结算方式、进货时间、经手人、商品信息、品种数量、货品总数、合计金额、验收结论等信息，以记录进货事件详细。 管理员通过输入进货票号等添加入库信息，主要实现在JinHuoDan.java中，其中入库按钮的监听事件如下：for (int i = 0; i &lt; rows; i++) { TbSpinfo spinfo = (TbSpinfo) table.getValueAt(i, 0); String djStr = (String) table.getValueAt(i, 6); String slStr = (String) table.getValueAt(i, 7); Double dj = Double.valueOf(djStr); Integer sl = Integer.valueOf(slStr); TbRukuDetail detail = new TbRukuDetail(); detail.setTabSpinfo(spinfo.getId()); detail.setTabRukuMain(ruMain.getRkId()); detail.setDj(dj); detail.setSl(sl); set.add(detail); } boolean rs = Dao.insertRukuInfo(ruMain); if (rs) { JOptionPane.showMessageDialog(JinHuoDan.this, “入库完成”); DefaultTableModel dftm = new DefaultTableModel(); table.setModel(dftm); initTable(); pzs.setText(“0”); hpzs.setText(“0”); hjje.setText(“0”); }信息初始化表格显示 private void initTable() { String[] columnNames = {“商品名称”, “商品编号”, “产地”, “单位”, “规格”, “包装”, “单价”, “数量”, “批号”, “批准文号”}; ((DefaultTableModel) table.getModel()) .setColumnIdentifiers(columnNames); TableColumn column = table.getColumnModel().getColumn(0); final DefaultCellEditor editor = new DefaultCellEditor(sp); editor.setClickCountToStart(2); column.setCellEditor(editor); } 4.2.2 进货退货选择“进货管理”/“进货退货”按钮，在弹出的窗体中进行添加退货信息操作。进货退货主要用于向系统中记录发送的退货信息。可设置并存储退货票号、供应商、联系人、结算方式、退货时间、经手人、商品信息、品种数量、货品总数、合计金额、验收结论等信息，以记录退货事件详细。 管理员向系统添加退货信息时，填入数据的有效则会更新表格sp = new JComboBox(); sp.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { TbKucun info = (TbKucun) sp.getSelectedItem(); if (info != null &amp;&amp; info.getId() != null) { updateTable(); } } });操作成功后，会通过stopTableCellEditing()函数停止表格单元的编辑 private void stopTableCellEditing() { TableCellEditor cellEditor = table.getCellEditor(); if (cellEditor != null) cellEditor.stopCellEditing(); }4.3 销售管理模块设计4.3.1销售单选择“销售管理”/“销售单”按钮，在弹出的窗体中进行添加商品销售信息操作。销售单主要用于向系统中记录已销售的商品信息。可设置并存储销售票号、客户、联系人、结算方式、销售时间、经手人、商品信息、品种数量、货品总数、合计金额、验收结论等信息，以记录销售事件详细。 程序通过定义一个list类型的对象加载出筛选出的数据库中现存的商品保存在list对象里。数据库在事务中添加销售信息，通过insertSellInfo（）函数添加到记录中。 insert(“insert into tb_sell_detail values(‘“ + sellMain.getSellId() + &quot;&apos;,&apos;&quot; + details.getSpid() + &quot;&apos;,&quot; + details.getDj() + &quot;,&quot; + details.getSl() + &quot;)&quot;); 在XiaoShouDan.java中，设置单击添加按钮就会在表格中添加新的一行 JButton tjButton = new JButton(“添加”); tjButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { // 初始化票号 initPiaoHao(); // 结束表格中没有编写的单元 stopTableCellEditing(); // 如果表格中还包含空行，就再添加新行 for (int i = 0; i &lt; table.getRowCount(); i++) { TbSpinfo info = (TbSpinfo) table.getValueAt(i, 0); if (table.getValueAt(i, 0) == null) return; } DefaultTableModel model = (DefaultTableModel) table.getModel(); model.addRow(new Vector()); } });添加成功后，会修改库存表相应记录 Item item = new Item(); item.setId(details.getSpid()); TbSpinfo spInfo = getSpInfo(item); if (spInfo.getId() != null &amp;&amp; !spInfo.getId().isEmpty()) { TbKucun kucun = getKucun(item); if (kucun.getId() != null &amp;&amp; !kucun.getId().isEmpty()) { int sl = kucun.getKcsl() - details.getSl(); update(“update tb_kucun set kcsl=” + sl + “ where id=’” + kucun.getId() + &quot;&apos;&quot;); } } 4.3.2销售退货选择“销售管理”/“销售退货”按钮，在弹出的窗体中进行添加商品退货信息操作。销售单主要用于向系统中记录销售后被退货的商品信息。可设置并存储销退票号、客户、联系人、结算方式、退货时间、经手人、商品信息、品种数量、货品总数、合计金额、验收结论等信息，以记录销退事件详细。 填写完退货信息后，经actionPerformed（）函数确认有效，则单击添加按钮后会在表格中添加新的一行 JButton tjButton = new JButton(“添加”); tjButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { // 初始化票号 initPiaoHao(); // 结束表格中没有编写的单元 stopTableCellEditing(); // 如果表格中还包含空行，就不再添加新行 for (int i = 0; i &lt; table.getRowCount(); i++) { TbSpinfo info = (TbSpinfo) table.getValueAt(i, 0); if (info == null || info.getId().isEmpty()) return; } DefaultTableModel model = (DefaultTableModel) table.getModel(); model.addRow(new Vector()); initSpBox(); } }); setupComponet(tjButton, 4, 4, 1, 1, false); 4.4 查询统计模块设计企业进销存管理系统中的查询统计模块包括客户查询、商品查询、供应商查询、销售查询、销售退货查询、入库查询、入库退货查询和销售排行查询功能.。客户查询、商品查询和供应商查询3个模块的作用和实现方式基本相同。4.4.1客户查询选择“查询统计”/“客户查询”按钮，在弹出的窗体中进行对客户信息的查询操作。客户查询功能主要用于查询系统中的客户信息，其查询方式可以按照客户全称、客户简称进行匹配查询和模糊查询，也可以直接显示全部数据。程序界面如图所示： 对数据库中的tb khinfo表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。核心为Dao类的getKhInfos（）函数，查询出的信息会加载在list中。查询语句如下：if (!conditionString.isEmpty()) { String sql = “select * from tb_khinfo where “; if (condition.equals(“客户全称”)) { if (conditionOperation.equals(“等于”)) list = Dao.findForList(sql + “khname=’” + conditionString + &quot;&apos;&quot;); else list = Dao.findForList(sql + &quot;khname like &apos;%&quot; + conditionString + &quot;%&apos;&quot;); } else { if (conditionOperation.equals(&quot;等于&quot;)) list = Dao.findForList(sql + &quot;jian=&apos;&quot; + conditionString + &quot;&apos;&quot;); else list = Dao.findForList(sql + &quot;jian like &apos;%&quot; + conditionString + &quot;%&apos;&quot;); } updateTable(list, dftm); } else showAllButton.doClick(); 4.4.2商品查询选择“查询统计”/“商品查询”按钮，在弹出的窗体中进行对商品信息的查询操作。商品查询功能主要用于查询系统中的商品信息，其查询方式可以按照商品名称、供应商全称、产地、规格进行匹配查询和模糊查询，也可以直接显示全部数据。程序界面如图所示： 对数据库中的tb spinfo表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。核心为Dao类的 getSpInfo（）函数查询后的信息会加载在list中，查询语句如下：if (conOperation.equals(“等于”)) { if (conName.equals(“商品名称”)) list = Dao.findForList(sql + “spname=’” + content + “‘“); if (conName.equals(“供应商全称”)) list = Dao.findForList(sql + “gysname=’” + content + “‘“); if (conName.equals(“产地”)) list = Dao.findForList(sql + “cd=’” + content + “‘“); if (conName.equals(“规格”)) list = Dao.findForList(sql + “gg=’” + content + “‘“); } else { if (conName.equals(“商品名称”)) list = Dao.findForList(sql + “spname like ‘%” + content + &quot;%&apos;&quot;); if (conName.equals(&quot;供应商全称&quot;)) list = Dao.findForList(sql + &quot;gysname like &apos;%&quot; + content + &quot;%&apos;&quot;); if (conName.equals(&quot;产地&quot;)) list = Dao.findForList(sql + &quot;cd like &apos;%&quot; + content + &quot;%&apos;&quot;); if (conName.equals(&quot;规格&quot;)) list = Dao.findForList(sql + &quot;gg like &apos;%&quot; + content + &quot;%&apos;&quot;); } return list; 4.4.3供应商查询选择“查询统计”/“供应商查询”按钮，在弹出的窗体中进行对供应商信息的查询操作。商品查询功能主要用于查询系统中的商品信息，其查询方式可以按照供应商全称、简称进行匹配查询和模糊查询，也可以直接显示全部数据。程序界面如图所示： 对数据库中的tb gysinfo表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。核心为Dao类的 getGysInfo（）函数查询后的信息会加载在list中，查询语句如下：if (conName.equals(“供应商全称”)) { if (conOperation.equals(“等于”)) list = Dao.findForList(sql + “name=’” + content + “‘“); else list = Dao.findForList(sql + “name like ‘%” + content + &quot;%&apos;&quot;); } else { if (conOperation.equals(&quot;等于&quot;)) list = Dao.findForList(sql + &quot;jc=&apos;&quot; + content + &quot;&apos;&quot;); else list = Dao.findForList(sql + &quot;jc like &apos;%&quot; + content + &quot;%&apos;&quot;); } updateTable(list, dftm); } 4.4.4销售查询选择“查询统计”/“销售查询”按钮，在弹出的窗体中进行对销售信息进行查询操作。销售查询功能主要用于查询系统中的销售信息，其查询方式可以按照客户全称、销售票号进行匹配查询和模糊查询。另外，可以指定销售日期查询。程序界面如图所示： 对数据库中的tb sellmai表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。按照日期查询，设置label标签，并加载到list中final JLabel label_1 = new JLabel(); label_1.setText(“指定查询日期 从”); final GridBagConstraints gridBagConstraints_8 = new GridBagConstraints(); gridBagConstraints_8.anchor = GridBagConstraints.EAST; gridBagConstraints_8.gridy = 1; gridBagConstraints_8.gridx = 1; getContentPane().add(label_1, gridBagConstraints_8);查询条件如下：list = Dao.findForList(“select * from v_sellView where “ + con + opstr + (oper == 0 ? &quot;&apos;&quot;+cont+&quot;&apos;&quot; : &quot;&apos;%&quot; + cont + &quot;%&apos;&quot;) + (selDate ? &quot; and xsdate&gt;&apos;&quot; + startDate.getText() + &quot;&apos; and xsdate&lt;=&apos;&quot; + endDate.getText()+&quot; 23:59:59&apos;&quot; : &quot;&quot;)); Iterator iterator = list.iterator(); updateTable(iterator); 4.4.5销售退货查询选择“查询统计”/“销售退货查询”按钮，在弹出的窗体中进行对销售退货信息的查询操作。销售退货查询功能主要用于查询系统中的销售后被退货的信息，其查询方式可以按照客户全称、销退票号进行匹配查询和模糊查询。另外，可以指定销售日期查询。程序界面如图所示： 对数据库中的tb xsth main表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。 按照日期查询，设置label标签，并加载到list中，查询语句如下：list = Dao.findForList(“select * from v_xsthView where “ + con + opstr + (oper == 0 ? &quot;&apos;&quot;+cont+&quot;&apos;&quot; : &quot;&apos;%&quot; + cont + &quot;%&apos;&quot;) + (selDate ? &quot; and thdate&gt;&apos;&quot; + startDate.getText() + &quot;&apos; and thdate&lt;=&apos;&quot; + endDate.getText()+&quot; 23:59:59&apos;&quot; : &quot;&quot;)); Iterator iterator = list.iterator(); updateTable(iterator); 4.4.6入库查询选择“查询统计”/“入库查询”按钮，在弹出的窗体中进行对商品入库信息的查询操作。入库查询功能主要用于查询系统中的入库商品的信息，其查询方式可以按照商品名称、商品编号、供应商全称进行匹配查询和模糊查询。另外，可以指定销售日期查询。程序界面如图所示： 对数据库中的tb kucun表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。 按照日期查询，设置label标签，并加载到list中，查询语句如下： if (selectDate.isSelected()) { String sDate = startDate.getText().trim(); String eDate = endDate.getText().trim(); list = Dao.findForList(sql + conditionStr + “ “ + operationStr + &quot; and rkdate&gt;=&apos;&quot; + sDate + &quot;&apos; and rkdate&lt;=&apos;&quot; + eDate + &quot; 23:59:59&apos;&quot;); } else { list = Dao.findForList(sql + conditionStr + &quot; &quot; + operationStr); } 4.4.7入库退货查询选择“查询统计”/“入库退货查询”按钮，在弹出的窗体中进行对入库商品退货的信息查询操作。入库退货查询功能主要用于查询系统中的入库后退货商品的信息，其查询方式可以按照商品名称、商品编号、供应商全称进行匹配查询和模糊查询。另外，可以指定销售日期查询。程序界面如图所示： 对数据库中的tb rkth main表进行遍历并输出；为每行添加监听事件，对当前选中行的信息实现传值到页面的jtextfield文本框里。 按照日期查询，设置label标签，并加载到list中，查询语句如下： if (selectDate.isSelected()) { String sDate = startDate.getText().trim(); String eDate = endDate.getText().trim(); list = Dao.findForList(sql + conditionStr + “ “ + operationStr + &quot; and rtdate&gt;=&apos;&quot; + sDate + &quot;&apos; and rtdate&lt;=&apos;&quot; + eDate + &quot; 23:59:59&apos;&quot;); } else { list = Dao.findForList(sql + conditionStr + &quot; &quot; + operationStr); } 4.4.8销售排行选择“查询统计”/“销售排行”按钮，在弹出的窗体中进行对销售信息排行查询操作。销售排行功能主要用于查询系统中的售出商品的信息，其查询方式可以指定销售日期，按金额或数量，进行升/降序排列查询。程序界面如图所示： 按升序降序排列函数如下：operation = new JComboBox(); operation.setModel(new DefaultComboBoxModel( new String[]{“升序排列”, “降序排列”})); setupComponet(operation, 7, 0, 1, 30, true);按时间、数量排序如下： setupComponet(new JLabel(&quot; 月份的销售信息，按&quot;), 4, 0, 1, 1, false); condition = new JComboBox(); condition.setModel(new DefaultComboBoxModel(new String[]{&quot;金额&quot;, &quot;数量&quot;})); setupComponet(condition, 5, 0, 1, 30, true); 4.5 库存管理模块设计4.5.1库存盘点选择“库存管理”/“库存盘点”按钮，在弹出的窗体中进行查看商品的库存的品种数、剩余数量等信息操作。库存盘点功能主要用于查询并显示系统中的库中商品的详细信息，以便于盘点员了解商品情况。程序界面如图所示： 获取数据库中的库存信息表，展示在列表中，初始化表格如下private void initTable() { String[] columnNames = {“商品名称”, “商品编号”, “供应商”, “产地”, “单位”, “规格”, “单价”, “数量”, “包装”, “盘点数量”, “损益数量”};表格单元为只读模式 TableColumn column = table.getColumnModel().getColumn(i); column.setCellEditor(readOnlyEditor); } TableColumn pdColumn = table.getColumnModel().getColumn(9); TableColumn syColumn = table.getColumnModel().getColumn(10); pdColumn.setCellEditor(pdEditor); syColumn.setCellEditor(readOnlyEditor); 4.5.2价格调整选择“库存管理”/“价格调整”按钮，在弹出的窗体中进行对商品价格的调整操作。价格调整功能主要用于调整系统中的在售商品的信息，其调整方式是可以选择商品名称更改并保存它的单价。程序界面如图所示： 主要通过updateJinE()实现价格的调整，并设置商品选择时间的监听器class ItemActionListener implements ItemListener {// 商品选择事件监听器 public void itemStateChanged(final ItemEvent e) { Object selectedItem = shangPinMingCheng.getSelectedItem(); if (selectedItem == null) return; Item item = (Item) selectedItem; kcInfo = Dao.getKucun(item); if (kcInfo.getId() == null) return; int dj, sl; dj = kcInfo.getDj().intValue(); sl = kcInfo.getKcsl().intValue(); chanDi.setText(kcInfo.getCd()); jianCheng.setText(kcInfo.getJc()); baoZhuang.setText(kcInfo.getBz()); danWei.setText(kcInfo.getDw()); danJia.setText(kcInfo.getDj() + “”); kuCunShuLiang.setText(kcInfo.getKcsl() + “”); kuCunJinE.setText(dj * sl + “”); guiGe.setText(kcInfo.getGg()); } }调整金额完毕，会相应更新数据库中tb kucun 表中的商品价格class OkActionListener implements ActionListener { public void actionPerformed(final ActionEvent e) { kcInfo.setDj(Double.valueOf(danJia.getText())); kcInfo.setKcsl(Integer.valueOf(kuCunShuLiang.getText())); int rs = Dao.updateKucunDj(kcInfo); if (rs &gt; 0) JOptionPane.showMessageDialog(getContentPane(), “价格调整完毕。”, kcInfo.getSpname() + “价格调整”, JOptionPane.QUESTION_MESSAGE); } }4.6系统管理模块设计4.6.1用户管理选择“系统管理”/“用户管理”按钮，在弹出的窗体中进行对操作员信息的添加、修改以及删除操作。1.添加用户设置系统操作员的登录名称、用户姓名、密码。程序界面如图所示： 实现的类为CzyGL.java和TJCzy.java，在CzyGL.java定义了添加用户的方法，在TJCzy.java实现相应方法。public class CzyGL extends JInternalFrame { public CzyGL() { setIconifiable(true); setClosable(true); setBounds(100, 100, 491, 287); setTitle(“用户管理”); JTabbedPane tabPane = new JTabbedPane(); final TJCzy tjPanel = new TJCzy(); final ShanChuCaoZuoYuan delPanel = new ShanChuCaoZuoYuan(); tabPane.addTab(“添加用户”, null, tjPanel, “添加用户”); tabPane.addTab(“删除用户”, null, delPanel, “删除用户”); getContentPane().add(tabPane); tabPane.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { delPanel.initTable(); } }); pack(); setVisible(true); } }final JLabel label_4 = new JLabel(); label_4.setFont(new Font(“”, Font.PLAIN, 14)); label_4.setText(“登录名称：”);final JLabel label = new JLabel(); label.setFont(new Font(“”, Font.PLAIN, 14)); label.setText(“用户姓名：”);final JLabel label_2 = new JLabel(); label_2.setFont(new Font(“”, Font.PLAIN, 14)); label_2.setText(“输入密码：”);final JLabel label_3 = new JLabel(); label_3.setFont(new Font(“”, Font.PLAIN, 14)); label_3.setText(“确认密码：”); 2.删除用户如果某个员工离职，可选中并删除对应操作员或管理员身份。程序界面如图所示： 实现的类为CzyGL.java和ShanChuCaoZuoYuan.java，在CzyGL.java定义了添加用户的方法，在ShanChuCaoZuoYuan.java实现相应方法。ublic class CzyGL extends JInternalFrame { public CzyGL() { setIconifiable(true); setClosable(true); setBounds(100, 100, 491, 287); setTitle(“用户管理”); JTabbedPane tabPane = new JTabbedPane(); final TJCzy tjPanel = new TJCzy(); final ShanChuCaoZuoYuan delPanel = new ShanChuCaoZuoYuan(); tabPane.addTab(“添加用户”, null, tjPanel, “添加用户”); tabPane.addTab(“删除用户”, null, delPanel, “删除用户”); getContentPane().add(tabPane); tabPane.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { delPanel.initTable(); } }); pack(); setVisible(true); }}删除操作如下：public void actionPerformed(final ActionEvent e) { int op = JOptionPane.showConfirmDialog(ShanChuCaoZuoYuan.this, “确认要删除该用户吗？”); if (op == JOptionPane.OK_OPTION) { Dao.delete(“delete tb_userlist where username=’” + loginName.getText() + &quot;&apos;&quot;); loginName.setText(&quot;&quot;); passField.setText(&quot;&quot;); userName.setText(&quot;&quot;); initTable(); } } 4.6.2更改密码选择“系统管理”/“更改密码”按钮，在弹出的窗体中进行对操作员的密码修改操作。设置当前自己的新密码。程序界面如图所示： 为更改密码设置监听事件：public void actionPerformed(final ActionEvent e) { if (oldPass.getText().equals(user.getPass())) { if (newPass1.getText().equals(newPass2.getText())) { user.setPass(newPass1.getText()); Dao.updateUser(user); oldPass.setText(null); newPass1.setText(null); newPass2.setText(null); JOptionPane.showMessageDialog(getContentPane(), “密码修改成功。”); }else { JOptionPane.showMessageDialog(getContentPane(), “两次输入的密码不一致，请重新输入。”); } }else { JOptionPane.showMessageDialog(getContentPane(), “旧密码输入错误，请确认密码。”); } }4.6.3权限管理选择“系统管理”/“权限管理”按钮，在弹出的窗体中进行对用户的权限设置操作。设置某个操作员和管理员的新密码。程序界面如图所示： 定位用户信息的下拉选择框 setupComponet(userCombo, 1, 2, 2, 0, true); modifyButton = new JButton(“修改”); closeButton = new JButton(“关闭”); JPanel panel = new JPanel(); panel.add(modifyButton); panel.add(closeButton); setupComponet(panel, 3, 2, 1, 0, false);处理修改按钮的单击事件 modifyButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Item item = (Item) userCombo.getSelectedItem(); TbUserlist user = Dao.getUser(item); int index = quanXian.getSelectedIndex(); if (index == 0) user.setQuan(“a”); else user.setQuan(“c”); if (Dao.updateUser(user) &gt;= 1) JOptionPane.showMessageDialog(QuanManager.this, “修改完成”); else JOptionPane.showMessageDialog(QuanManager.this, “修改失败”); } });第五章结论本系统采用Java语言开发，用Swing进行UI设计，着力于全面详细的覆盖到进销管理系统应有的每个功能。本系统所存数据量较大，采用Microsoft SQL Server数据库是考虑到了它可以承受系统的数据库并能提高安全性和稳定性。本系统能满足绝大多数功能需求，对于各个企业的实际情况，需要根据个体因素对程序进行升级调整。","categories":[],"tags":[]}],"categories":[],"tags":[]}